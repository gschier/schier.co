// Code generated by banister; DO NOT EDIT.
package gen

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	sq "github.com/Masterminds/squirrel"
	pq "github.com/lib/pq"
	"time"
)

// Store defines a data store
type Store struct {
	db     *sql.DB
	config StoreConfig

	// model managers

	BlogPosts             *blogPostManager
	NewsletterSubscribers *newsletterSubscriberManager
	Sessions              *sessionManager
	Users                 *userManager
	NewsletterSends       *newsletterSendManager
}

// NewStore returns a new store instance
func NewStore(db *sql.DB, c StoreConfig) *Store {
	return &Store{
		BlogPosts:             newBlogPostManager(db, c, c.BlogPostConfig),
		NewsletterSends:       newNewsletterSendManager(db, c, c.NewsletterSendConfig),
		NewsletterSubscribers: newNewsletterSubscriberManager(db, c, c.NewsletterSubscriberConfig),
		Sessions:              newSessionManager(db, c, c.SessionConfig),
		Users:                 newUserManager(db, c, c.UserConfig),
		config:                c,
		db:                    db,
	}
}

// StoreConfig holds configuration for the store
type StoreConfig struct {
	connectionStr         string
	maxIdleConnections    int
	maxOpenConnections    int
	connectionMaxLifetime time.Duration

	// model configs

	BlogPostConfig             BlogPostConfig
	NewsletterSubscriberConfig NewsletterSubscriberConfig
	SessionConfig              SessionConfig
	UserConfig                 UserConfig
	NewsletterSendConfig       NewsletterSendConfig
}

// Where contains helpers for filtering querysets
var Where = struct {
	BlogPost             blogPostFilters
	NewsletterSubscriber newsletterSubscriberFilters
	Session              sessionFilters
	User                 userFilters
	NewsletterSend       newsletterSendFilters
}{}

// Set contains helpers for setting fields during inserts and updates
var Set = struct {
	BlogPost             blogPostSetters
	NewsletterSubscriber newsletterSubscriberSetters
	Session              sessionSetters
	User                 userSetters
	NewsletterSend       newsletterSendSetters
}{}

// OrderBy contains helpers for sorting query results
var OrderBy = struct {
	BlogPost             blogPostOrders
	NewsletterSubscriber newsletterSubscriberOrders
	Session              sessionOrders
	User                 userOrders
	NewsletterSend       newsletterSendOrders
}{
	BlogPost:             newBlogPostOrders(),
	NewsletterSend:       newNewsletterSendOrders(),
	NewsletterSubscriber: newNewsletterSubscriberOrders(),
	Session:              newSessionOrders(),
	User:                 newUserOrders(),
}

// BlogPost represents a row in the "blog_posts" table
type BlogPost struct {
	ID         string    `json:"id"`         // id VARCHAR(25) PRIMARY KEY
	CreatedAt  time.Time `json:"createdAt"`  // created_at TIMESTAMP WITH TIME ZONE NOT NULL
	UpdatedAt  time.Time `json:"updatedAt"`  // updated_at TIMESTAMP WITH TIME ZONE NOT NULL
	UserID     string    `json:"userId"`     // user_id VARCHAR(25) NOT NULL
	Content    string    `json:"content"`    // content TEXT NOT NULL
	Date       time.Time `json:"date"`       // date TIMESTAMP WITH TIME ZONE NOT NULL
	EditedAt   time.Time `json:"editedAt"`   // edited_at TIMESTAMP WITH TIME ZONE NOT NULL
	Image      string    `json:"image"`      // image TEXT NOT NULL
	Published  bool      `json:"published"`  // published BOOLEAN NOT NULL
	Score      int64     `json:"score"`      // score INTEGER NOT NULL
	Shares     int64     `json:"shares"`     // shares INTEGER NOT NULL
	Slug       string    `json:"slug"`       // slug TEXT NOT NULL UNIQUE
	Stage      int64     `json:"stage"`      // stage INTEGER NOT NULL
	Title      string    `json:"title"`      // title TEXT NOT NULL
	Unlisted   bool      `json:"unlisted"`   // unlisted BOOLEAN NOT NULL
	Views      int64     `json:"views"`      // views INTEGER NOT NULL
	VotesTotal int64     `json:"votesTotal"` // votes_total INTEGER NOT NULL
	VotesUsers int64     `json:"votesUsers"` // votes_users INTEGER NOT NULL
	Tags       []string  `json:"tags"`       // tags TEXT[] NOT NULL
	Donations  int64     `json:"donations"`  // donations INTEGER NOT NULL
}

// NewBlogPost returns a new instance of BlogPost with default values
func NewBlogPost() *BlogPost {
	return &BlogPost{
		Content:    "",
		CreatedAt:  time.Time{},
		Date:       time.Time{},
		Donations:  int64(0),
		EditedAt:   time.Time{},
		ID:         "",
		Image:      "",
		Published:  false,
		Score:      int64(0),
		Shares:     int64(0),
		Slug:       "",
		Stage:      int64(0),
		Tags:       make([]string, 0),
		Title:      "",
		Unlisted:   false,
		UpdatedAt:  time.Time{},
		UserID:     "",
		Views:      int64(0),
		VotesTotal: int64(0),
		VotesUsers: int64(0),
	}
}

// PrintJSON prints out a JSON string of the model for debugging
func (model *BlogPost) PrintJSON() {
	b, err := json.MarshalIndent(model, "// ", "  ")
	if err != nil {
		panic(err)
	}

	fmt.Printf("\n// var %s %T = %s\n\n", "blogPost", model, b)
}

type BlogPostConfig struct {
	// HookPreInsert sets a hook for the model that will
	// be called before the model is inserted into the database.
	HookPreInsert func(m *BlogPost)

	// HookPostInsert sets a hook for the model that will
	// be called after the model is inserted into the database.
	HookPostInsert func(m *BlogPost)

	// HookPreUpdate sets a hook for the model that will
	// be called before the model is updated into the database.
	HookPreUpdate func(m *BlogPost)

	// HookPostUpdate sets a hook for the model that will
	// be called after the model is updated into the database.
	HookPostUpdate func(m *BlogPost)

	// HookPreDelete sets a hook for the model that will
	// be called before the model is deleted into the database.
	HookPreDelete func(m *BlogPost)

	// HookPostDelete sets a hook for the model that will
	// be called after the model is deleted into the database.
	HookPostDelete func(m *BlogPost)
}
type blogPostManager struct {
	db          *sql.DB
	storeConfig StoreConfig
	config      BlogPostConfig
}

func newBlogPostManager(db *sql.DB, storeConfig StoreConfig, config BlogPostConfig) *blogPostManager {
	return &blogPostManager{
		config:      config,
		db:          db,
		storeConfig: storeConfig,
	}
}
func (mgr *blogPostManager) Filter(filter ...blogPostFilterArg) *blogPostQueryset {
	v := newBlogPostQueryset(mgr)
	v.Filter(filter...)
	return v
}
func (mgr *blogPostManager) Exclude(exclude ...blogPostFilterArg) *blogPostQueryset {
	v := newBlogPostQueryset(mgr)
	v.Exclude(exclude...)
	return v
}
func (mgr *blogPostManager) Delete(m *BlogPost) error {
	// Call hook if provided
	if mgr.config.HookPreDelete != nil {
		mgr.config.HookPreDelete(m)
	}

	// Call delete on queryset with PK as the filter
	err := mgr.Filter(blogPostFilterArg{filter: &sq.Eq{"id": m.ID}}).Delete()
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostDelete != nil {
		mgr.config.HookPostDelete(m)
	}

	return nil
}
func (mgr *blogPostManager) DeleteP(m *BlogPost) {
	err := mgr.Delete(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *blogPostManager) Insert(set ...blogPostSetterArg) (*BlogPost, error) {
	m := mgr.newModel(set...)
	err := mgr.insertInstance(m)
	if err != nil {
		return nil, err
	}
	return m, err
}
func (mgr *blogPostManager) InsertP(set ...blogPostSetterArg) *BlogPost {
	v, err := mgr.Insert(set...)
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *blogPostManager) Validate(m *BlogPost) error {
	if m.ID == "" {
		return errors.New("BlogPost.ID cannot be blank")
	}
	if m.UserID == "" {
		return errors.New("BlogPost.UserID cannot be blank")
	}
	if m.Slug == "" {
		return errors.New("BlogPost.Slug cannot be blank")
	}
	if m.Title == "" {
		return errors.New("BlogPost.Title cannot be blank")
	}
	return nil
}
func (mgr *blogPostManager) ValidateP(m *BlogPost) {
	err := mgr.Validate(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *blogPostManager) insertInstance(m *BlogPost) error {
	// Call hook if provided
	if mgr.config.HookPreInsert != nil {
		mgr.config.HookPreInsert(m)
	}

	err := mgr.Validate(m)
	if err != nil {
		return err
	}

	query := sq.Insert("blog_posts")
	query = query.Columns(
		"id",
		"created_at",
		"updated_at",
		"user_id",
		"content",
		"date",
		"edited_at",
		"image",
		"published",
		"score",
		"shares",
		"slug",
		"stage",
		"title",
		"unlisted",
		"views",
		"votes_total",
		"votes_users",
		"tags",
		"donations")

	query = query.Values(
		m.ID,
		m.CreatedAt,
		m.UpdatedAt,
		m.UserID,
		m.Content,
		m.Date,
		m.EditedAt,
		m.Image,
		m.Published,
		m.Score,
		m.Shares,
		m.Slug,
		m.Stage,
		m.Title,
		m.Unlisted,
		m.Views,
		m.VotesTotal,
		m.VotesUsers,
		pq.Array(m.Tags),
		m.Donations)

	query = query.Suffix("RETURNING \"id\"")
	q, args := mgr.toSQL(query)
	result := mgr.db.QueryRow(q, args...)

	err = result.Scan(&m.ID)
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostInsert != nil {
		mgr.config.HookPostInsert(m)
	}

	return nil
}
func (mgr *blogPostManager) Update(m *BlogPost) error {
	// Call hook if provided
	if mgr.config.HookPreUpdate != nil {
		mgr.config.HookPreUpdate(m)
	}

	// Call update on queryset with PK as the filter
	err := mgr.Filter(blogPostFilterArg{filter: &sq.Eq{"id": m.ID}}).Update(blogPostSetterArg{
		field: "id",
		value: m.ID,
	}, blogPostSetterArg{
		field: "created_at",
		value: m.CreatedAt,
	}, blogPostSetterArg{
		field: "updated_at",
		value: m.UpdatedAt,
	}, blogPostSetterArg{
		field: "user_id",
		value: m.UserID,
	}, blogPostSetterArg{
		field: "content",
		value: m.Content,
	}, blogPostSetterArg{
		field: "date",
		value: m.Date,
	}, blogPostSetterArg{
		field: "edited_at",
		value: m.EditedAt,
	}, blogPostSetterArg{
		field: "image",
		value: m.Image,
	}, blogPostSetterArg{
		field: "published",
		value: m.Published,
	}, blogPostSetterArg{
		field: "score",
		value: m.Score,
	}, blogPostSetterArg{
		field: "shares",
		value: m.Shares,
	}, blogPostSetterArg{
		field: "slug",
		value: m.Slug,
	}, blogPostSetterArg{
		field: "stage",
		value: m.Stage,
	}, blogPostSetterArg{
		field: "title",
		value: m.Title,
	}, blogPostSetterArg{
		field: "unlisted",
		value: m.Unlisted,
	}, blogPostSetterArg{
		field: "views",
		value: m.Views,
	}, blogPostSetterArg{
		field: "votes_total",
		value: m.VotesTotal,
	}, blogPostSetterArg{
		field: "votes_users",
		value: m.VotesUsers,
	}, blogPostSetterArg{
		field: "tags",
		value: pq.Array(m.Tags),
	}, blogPostSetterArg{
		field: "donations",
		value: m.Donations,
	})
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostUpdate != nil {
		mgr.config.HookPostUpdate(m)
	}

	return nil
}
func (mgr *blogPostManager) UpdateP(m *BlogPost) {
	err := mgr.Update(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *blogPostManager) All() ([]BlogPost, error) {
	return mgr.Filter().All()
}
func (mgr *blogPostManager) AllP() []BlogPost {
	v, err := mgr.All()
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *blogPostManager) None() ([]BlogPost, error) {
	return make([]BlogPost, 0), nil
}
func (mgr *blogPostManager) NoneP() []BlogPost {
	v, err := mgr.None()
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *blogPostManager) Get(id string) (*BlogPost, error) {
	return mgr.Filter(blogPostFilterArg{filter: sq.Eq{"\"blog_posts\".\"id\"": id}}).One()
}
func (mgr *blogPostManager) GetP(id string) *BlogPost {
	v, err := mgr.Get(id)
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *blogPostManager) newModel(set ...blogPostSetterArg) *BlogPost {
	m := NewBlogPost()

	// Apply setters to default struct
	for _, s := range set {
		switch s.field {
		case "id":
			m.ID = s.value.(string)
		case "created_at":
			m.CreatedAt = s.value.(time.Time)
		case "updated_at":
			m.UpdatedAt = s.value.(time.Time)
		case "user_id":
			m.UserID = s.value.(string)
		case "content":
			m.Content = s.value.(string)
		case "date":
			m.Date = s.value.(time.Time)
		case "edited_at":
			m.EditedAt = s.value.(time.Time)
		case "image":
			m.Image = s.value.(string)
		case "published":
			m.Published = s.value.(bool)
		case "score":
			m.Score = s.value.(int64)
		case "shares":
			m.Shares = s.value.(int64)
		case "slug":
			m.Slug = s.value.(string)
		case "stage":
			m.Stage = s.value.(int64)
		case "title":
			m.Title = s.value.(string)
		case "unlisted":
			m.Unlisted = s.value.(bool)
		case "views":
			m.Views = s.value.(int64)
		case "votes_total":
			m.VotesTotal = s.value.(int64)
		case "votes_users":
			m.VotesUsers = s.value.(int64)
		case "tags":
			m.Tags = s.value.([]string)
		case "donations":
			m.Donations = s.value.(int64)
		default:
			panic("invalid field for setter: " + s.field)
		}
	}

	return m
}
func (mgr *blogPostManager) toSQL(q sq.Sqlizer) (string, []interface{}) {
	query, args, err := q.ToSql()
	if err != nil {
		panic(err)
	}

	query, err = sq.Dollar.ReplacePlaceholders(query)
	if err != nil {
		panic(err)
	}

	return query, args
}

type blogPostQueryset struct {
	mgr     *blogPostManager
	filter  []blogPostFilterArg
	orderBy []blogPostOrderByArg
	limit   uint64
	offset  uint64
}

func newBlogPostQueryset(mgr *blogPostManager) *blogPostQueryset {
	return &blogPostQueryset{
		filter:  make([]blogPostFilterArg, 0),
		limit:   0,
		mgr:     mgr,
		offset:  0,
		orderBy: make([]blogPostOrderByArg, 0),
	}
}
func (qs *blogPostQueryset) Filter(filter ...blogPostFilterArg) *blogPostQueryset {
	qs.filter = append(qs.filter, filter...)
	return qs
}
func (qs *blogPostQueryset) Exclude(exclude ...blogPostFilterArg) *blogPostQueryset {
	q := sq.And{}
	j := make([]string, 0)
	for _, e := range exclude {
		q = append(q, e.filter)
		j = append(j, e.joins...)
	}

	qs.filter = append(qs.filter, blogPostFilterArg{
		filter: sq.ConcatExpr("NOT", q),
		joins:  j,
	})

	return qs
}
func (qs *blogPostQueryset) Sort(orderBy ...blogPostOrderByArg) *blogPostQueryset {
	qs.orderBy = append(qs.orderBy, orderBy...)
	return qs
}
func (qs *blogPostQueryset) Limit(limit uint64) *blogPostQueryset {
	qs.limit = limit
	return qs
}
func (qs *blogPostQueryset) Offset(offset uint64) *blogPostQueryset {
	qs.offset = offset
	return qs
}
func (qs *blogPostQueryset) Update(set ...blogPostSetterArg) error {
	query := sq.Update("blog_posts")

	// Apply setters to query
	for _, s := range set {
		query = query.Set(s.field, s.value)
	}

	// Apply filters to query
	for _, f := range qs.filter {
		query = query.Where(f.filter)
	}

	q, args := qs.toSQL(query)
	_, err := qs.mgr.db.Exec(q, args...)
	return err
}
func (qs *blogPostQueryset) UpdateP(set ...blogPostSetterArg) {
	err := qs.Update(set...)
	if err != nil {
		panic(err)
	}
}
func (qs *blogPostQueryset) All() ([]BlogPost, error) {
	query := qs.starSelect()
	q, args := qs.toSQL(query)

	rows, err := qs.mgr.db.Query(q, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := make([]BlogPost, 0)

	for rows.Next() {
		var m BlogPost
		err = qs.scan(rows, &m)
		if err != nil {
			return nil, err
		}
		items = append(items, m)
	}

	return items, err
}
func (qs *blogPostQueryset) AllP() []BlogPost {
	v, err := qs.All()
	if err != nil {
		panic(err)
	}
	return v
}
func (qs *blogPostQueryset) One() (*BlogPost, error) {
	items, err := qs.All()

	// Ensure we have a result
	if len(items) == 0 {
		return nil, sql.ErrNoRows
	}

	return &items[0], err
}
func (qs *blogPostQueryset) OneP() *BlogPost {
	v, err := qs.One()
	if err != nil {
		panic(err)
	}
	return v
}
func (qs *blogPostQueryset) Delete() error {
	query := sq.Delete("blog_posts")

	for _, w := range qs.filter {
		query = query.Where(w.filter)
	}

	q, args := qs.toSQL(query)
	_, err := qs.mgr.db.Exec(q, args...)
	return err
}
func (qs *blogPostQueryset) DeleteP() {
	err := qs.Delete()
	if err != nil {
		panic(err)
	}
}
func (qs *blogPostQueryset) scan(r *sql.Rows, m *BlogPost) error {
	return r.Scan(
		&m.ID,
		&m.CreatedAt,
		&m.UpdatedAt,
		&m.UserID,
		&m.Content,
		&m.Date,
		&m.EditedAt,
		&m.Image,
		&m.Published,
		&m.Score,
		&m.Shares,
		&m.Slug,
		&m.Stage,
		&m.Title,
		&m.Unlisted,
		&m.Views,
		&m.VotesTotal,
		&m.VotesUsers,
		pq.Array(&m.Tags),
		&m.Donations)
}
func (qs *blogPostQueryset) starSelect() sq.SelectBuilder {
	query := sq.Select(
		"\"blog_posts\".\"id\"",
		"\"blog_posts\".\"created_at\"",
		"\"blog_posts\".\"updated_at\"",
		"\"blog_posts\".\"user_id\"",
		"\"blog_posts\".\"content\"",
		"\"blog_posts\".\"date\"",
		"\"blog_posts\".\"edited_at\"",
		"\"blog_posts\".\"image\"",
		"\"blog_posts\".\"published\"",
		"\"blog_posts\".\"score\"",
		"\"blog_posts\".\"shares\"",
		"\"blog_posts\".\"slug\"",
		"\"blog_posts\".\"stage\"",
		"\"blog_posts\".\"title\"",
		"\"blog_posts\".\"unlisted\"",
		"\"blog_posts\".\"views\"",
		"\"blog_posts\".\"votes_total\"",
		"\"blog_posts\".\"votes_users\"",
		"\"blog_posts\".\"tags\"",
		"\"blog_posts\".\"donations\"").From("blog_posts")

	joinCheck := make(map[string]bool)

	// Assign filters and join if necessary
	for _, w := range qs.filter {
		query = query.Where(w.filter)
		for _, j := range w.joins {
			if _, ok := joinCheck[j]; ok {
				continue
			}
			joinCheck[j] = true
			query = query.Join(j)
		}
	}

	// Apply limit if set
	if qs.limit > 0 {
		query = query.Limit(qs.limit)
	}

	// Apply offset if set
	if qs.offset > 0 {
		query = query.Offset(qs.offset)
	}

	// Apply default order if none specified
	if len(qs.orderBy) == 0 {
		// TODO: Add default order-by
	}

	// Apply user-specified order
	for _, s := range qs.orderBy {
		query = query.OrderBy(s.field + " " + s.order)
	}

	return query
}
func (qs *blogPostQueryset) toSQL(q sq.Sqlizer) (string, []interface{}) {
	return qs.mgr.toSQL(q)
}

type blogPostFilterArg struct {
	filter sq.Sqlizer
	joins  []string
}
type blogPostOrderByArg struct {
	field string
	order string
	join  string
}
type blogPostSetterArg struct {
	field string
	value interface{}
}
type blogPostSetters struct{}

// ID sets the "id" field to the provided value.
func (blogPostSetters) ID(v string) blogPostSetterArg {
	return blogPostSetterArg{
		field: "id",
		value: v,
	}
}

// CreatedAt sets the "created_at" field to the provided value.
func (blogPostSetters) CreatedAt(v time.Time) blogPostSetterArg {
	return blogPostSetterArg{
		field: "created_at",
		value: v,
	}
}

// UpdatedAt sets the "updated_at" field to the provided value.
func (blogPostSetters) UpdatedAt(v time.Time) blogPostSetterArg {
	return blogPostSetterArg{
		field: "updated_at",
		value: v,
	}
}

// UserID sets the "user_id" field to the provided value.
func (blogPostSetters) UserID(v string) blogPostSetterArg {
	return blogPostSetterArg{
		field: "user_id",
		value: v,
	}
}

// Content sets the "content" field to the provided value.
func (blogPostSetters) Content(v string) blogPostSetterArg {
	return blogPostSetterArg{
		field: "content",
		value: v,
	}
}

// Date sets the "date" field to the provided value.
func (blogPostSetters) Date(v time.Time) blogPostSetterArg {
	return blogPostSetterArg{
		field: "date",
		value: v,
	}
}

// EditedAt sets the "edited_at" field to the provided value.
func (blogPostSetters) EditedAt(v time.Time) blogPostSetterArg {
	return blogPostSetterArg{
		field: "edited_at",
		value: v,
	}
}

// Image sets the "image" field to the provided value.
func (blogPostSetters) Image(v string) blogPostSetterArg {
	return blogPostSetterArg{
		field: "image",
		value: v,
	}
}

// Published sets the "published" field to the provided value.
func (blogPostSetters) Published(v bool) blogPostSetterArg {
	return blogPostSetterArg{
		field: "published",
		value: v,
	}
}

// Score sets the "score" field to the provided value.
func (blogPostSetters) Score(v int64) blogPostSetterArg {
	return blogPostSetterArg{
		field: "score",
		value: v,
	}
}

// Shares sets the "shares" field to the provided value.
func (blogPostSetters) Shares(v int64) blogPostSetterArg {
	return blogPostSetterArg{
		field: "shares",
		value: v,
	}
}

// Slug sets the "slug" field to the provided value.
func (blogPostSetters) Slug(v string) blogPostSetterArg {
	return blogPostSetterArg{
		field: "slug",
		value: v,
	}
}

// Stage sets the "stage" field to the provided value.
func (blogPostSetters) Stage(v int64) blogPostSetterArg {
	return blogPostSetterArg{
		field: "stage",
		value: v,
	}
}

// Title sets the "title" field to the provided value.
func (blogPostSetters) Title(v string) blogPostSetterArg {
	return blogPostSetterArg{
		field: "title",
		value: v,
	}
}

// Unlisted sets the "unlisted" field to the provided value.
func (blogPostSetters) Unlisted(v bool) blogPostSetterArg {
	return blogPostSetterArg{
		field: "unlisted",
		value: v,
	}
}

// Views sets the "views" field to the provided value.
func (blogPostSetters) Views(v int64) blogPostSetterArg {
	return blogPostSetterArg{
		field: "views",
		value: v,
	}
}

// VotesTotal sets the "votes_total" field to the provided value.
func (blogPostSetters) VotesTotal(v int64) blogPostSetterArg {
	return blogPostSetterArg{
		field: "votes_total",
		value: v,
	}
}

// VotesUsers sets the "votes_users" field to the provided value.
func (blogPostSetters) VotesUsers(v int64) blogPostSetterArg {
	return blogPostSetterArg{
		field: "votes_users",
		value: v,
	}
}

// Tags sets the "tags" field to the provided value.
func (blogPostSetters) Tags(v []string) blogPostSetterArg {
	return blogPostSetterArg{
		field: "tags",
		value: v,
	}
}

// Donations sets the "donations" field to the provided value.
func (blogPostSetters) Donations(v int64) blogPostSetterArg {
	return blogPostSetterArg{
		field: "donations",
		value: v,
	}
}

type blogPostOrders struct {
	ID         blogPostIDOrderByArg
	CreatedAt  blogPostCreatedAtOrderByArg
	UpdatedAt  blogPostUpdatedAtOrderByArg
	UserID     blogPostUserIDOrderByArg
	Content    blogPostContentOrderByArg
	Date       blogPostDateOrderByArg
	EditedAt   blogPostEditedAtOrderByArg
	Image      blogPostImageOrderByArg
	Published  blogPostPublishedOrderByArg
	Score      blogPostScoreOrderByArg
	Shares     blogPostSharesOrderByArg
	Slug       blogPostSlugOrderByArg
	Stage      blogPostStageOrderByArg
	Title      blogPostTitleOrderByArg
	Unlisted   blogPostUnlistedOrderByArg
	Views      blogPostViewsOrderByArg
	VotesTotal blogPostVotesTotalOrderByArg
	VotesUsers blogPostVotesUsersOrderByArg
	Tags       blogPostTagsOrderByArg
	Donations  blogPostDonationsOrderByArg
}

type blogPostIDOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostCreatedAtOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostUpdatedAtOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostUserIDOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostContentOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostDateOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostEditedAtOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostImageOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostPublishedOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostScoreOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostSharesOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostSlugOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostStageOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostTitleOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostUnlistedOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostViewsOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostVotesTotalOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostVotesUsersOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostTagsOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

type blogPostDonationsOrderByArg struct {
	// Asc orders results in ascending direction
	Asc blogPostOrderByArg

	// Desc orders results in descending direction
	Desc blogPostOrderByArg
}

func newBlogPostOrders() blogPostOrders {
	return blogPostOrders{
		Content: blogPostContentOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"content\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"content\"",
				join:  "",
				order: "DESC",
			},
		},
		CreatedAt: blogPostCreatedAtOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"created_at\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"created_at\"",
				join:  "",
				order: "DESC",
			},
		},
		Date: blogPostDateOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"date\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"date\"",
				join:  "",
				order: "DESC",
			},
		},
		Donations: blogPostDonationsOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"donations\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"donations\"",
				join:  "",
				order: "DESC",
			},
		},
		EditedAt: blogPostEditedAtOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"edited_at\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"edited_at\"",
				join:  "",
				order: "DESC",
			},
		},
		ID: blogPostIDOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"id\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"id\"",
				join:  "",
				order: "DESC",
			},
		},
		Image: blogPostImageOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"image\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"image\"",
				join:  "",
				order: "DESC",
			},
		},
		Published: blogPostPublishedOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"published\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"published\"",
				join:  "",
				order: "DESC",
			},
		},
		Score: blogPostScoreOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"score\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"score\"",
				join:  "",
				order: "DESC",
			},
		},
		Shares: blogPostSharesOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"shares\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"shares\"",
				join:  "",
				order: "DESC",
			},
		},
		Slug: blogPostSlugOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"slug\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"slug\"",
				join:  "",
				order: "DESC",
			},
		},
		Stage: blogPostStageOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"stage\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"stage\"",
				join:  "",
				order: "DESC",
			},
		},
		Tags: blogPostTagsOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"tags\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"tags\"",
				join:  "",
				order: "DESC",
			},
		},
		Title: blogPostTitleOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"title\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"title\"",
				join:  "",
				order: "DESC",
			},
		},
		Unlisted: blogPostUnlistedOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"unlisted\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"unlisted\"",
				join:  "",
				order: "DESC",
			},
		},
		UpdatedAt: blogPostUpdatedAtOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"updated_at\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"updated_at\"",
				join:  "",
				order: "DESC",
			},
		},
		UserID: blogPostUserIDOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"user_id\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"user_id\"",
				join:  "",
				order: "DESC",
			},
		},
		Views: blogPostViewsOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"views\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"views\"",
				join:  "",
				order: "DESC",
			},
		},
		VotesTotal: blogPostVotesTotalOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"votes_total\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"votes_total\"",
				join:  "",
				order: "DESC",
			},
		},
		VotesUsers: blogPostVotesUsersOrderByArg{
			Asc: blogPostOrderByArg{
				field: "\"blog_posts\".\"votes_users\"",
				join:  "",
				order: "ASC",
			},
			Desc: blogPostOrderByArg{
				field: "\"blog_posts\".\"votes_users\"",
				join:  "",
				order: "DESC",
			},
		},
	}
}

type blogPostIDFilter struct{}

func (blogPostIDFilter) Contains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" LIKE '%' || ? || '%'", v)}
}
func (blogPostIDFilter) Lt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" < ?", v)}
}
func (blogPostIDFilter) HasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" LIKE '%' || ?", v)}
}
func (blogPostIDFilter) Eq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" = ?", v)}
}
func (blogPostIDFilter) NotEq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" != ?", v)}
}
func (blogPostIDFilter) IHasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" ILIKE '%' || ?", v)}
}
func (blogPostIDFilter) Gt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" > ?", v)}
}
func (blogPostIDFilter) HasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" LIKE ? || '%'", v)}
}
func (blogPostIDFilter) Regex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" ~ ?", v)}
}
func (blogPostIDFilter) IRegex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" ~* ?", v)}
}
func (blogPostIDFilter) ILike(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" LIKE ?", v)}
}
func (blogPostIDFilter) IContains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" ILIKE '%' || ? || '%'", v)}
}
func (blogPostIDFilter) IHasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" ILIKE ? || '%'", v)}
}
func (blogPostIDFilter) Gte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" >= ?", v)}
}
func (blogPostIDFilter) Lte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"id\" <= ?", v)}
}

type blogPostCreatedAtFilter struct{}

func (blogPostCreatedAtFilter) Eq(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"created_at\" = ?", v)}
}
func (blogPostCreatedAtFilter) NotEq(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"created_at\" != ?", v)}
}
func (blogPostCreatedAtFilter) Before(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"created_at\" < ?", v)}
}
func (blogPostCreatedAtFilter) After(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"created_at\" > ?", v)}
}

type blogPostUpdatedAtFilter struct{}

func (blogPostUpdatedAtFilter) After(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"updated_at\" > ?", v)}
}
func (blogPostUpdatedAtFilter) Eq(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"updated_at\" = ?", v)}
}
func (blogPostUpdatedAtFilter) NotEq(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"updated_at\" != ?", v)}
}
func (blogPostUpdatedAtFilter) Before(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"updated_at\" < ?", v)}
}

type blogPostUserIDFilter struct{}

func (blogPostUserIDFilter) Regex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" ~ ?", v)}
}
func (blogPostUserIDFilter) Gt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" > ?", v)}
}
func (blogPostUserIDFilter) Gte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" >= ?", v)}
}
func (blogPostUserIDFilter) Lt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" < ?", v)}
}
func (blogPostUserIDFilter) HasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" LIKE ? || '%'", v)}
}
func (blogPostUserIDFilter) Eq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" = ?", v)}
}
func (blogPostUserIDFilter) NotEq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" != ?", v)}
}
func (blogPostUserIDFilter) Contains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" LIKE '%' || ? || '%'", v)}
}
func (blogPostUserIDFilter) Lte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" <= ?", v)}
}
func (blogPostUserIDFilter) HasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" LIKE '%' || ?", v)}
}
func (blogPostUserIDFilter) IHasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" ILIKE ? || '%'", v)}
}
func (blogPostUserIDFilter) IHasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" ILIKE '%' || ?", v)}
}
func (blogPostUserIDFilter) ILike(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" LIKE ?", v)}
}
func (blogPostUserIDFilter) IContains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" ILIKE '%' || ? || '%'", v)}
}
func (blogPostUserIDFilter) IRegex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"user_id\" ~* ?", v)}
}

type blogPostContentFilter struct{}

func (blogPostContentFilter) ILike(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" LIKE ?", v)}
}
func (blogPostContentFilter) IContains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" ILIKE '%' || ? || '%'", v)}
}
func (blogPostContentFilter) Regex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" ~ ?", v)}
}
func (blogPostContentFilter) IRegex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" ~* ?", v)}
}
func (blogPostContentFilter) IHasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" ILIKE ? || '%'", v)}
}
func (blogPostContentFilter) Contains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" LIKE '%' || ? || '%'", v)}
}
func (blogPostContentFilter) Eq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" = ?", v)}
}
func (blogPostContentFilter) Gte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" >= ?", v)}
}
func (blogPostContentFilter) HasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" LIKE ? || '%'", v)}
}
func (blogPostContentFilter) IHasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" ILIKE '%' || ?", v)}
}
func (blogPostContentFilter) NotEq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" != ?", v)}
}
func (blogPostContentFilter) Gt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" > ?", v)}
}
func (blogPostContentFilter) Lt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" < ?", v)}
}
func (blogPostContentFilter) Lte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" <= ?", v)}
}
func (blogPostContentFilter) HasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"content\" LIKE '%' || ?", v)}
}

type blogPostDateFilter struct{}

func (blogPostDateFilter) Eq(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"date\" = ?", v)}
}
func (blogPostDateFilter) NotEq(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"date\" != ?", v)}
}
func (blogPostDateFilter) Before(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"date\" < ?", v)}
}
func (blogPostDateFilter) After(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"date\" > ?", v)}
}

type blogPostEditedAtFilter struct{}

func (blogPostEditedAtFilter) After(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"edited_at\" > ?", v)}
}
func (blogPostEditedAtFilter) Eq(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"edited_at\" = ?", v)}
}
func (blogPostEditedAtFilter) NotEq(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"edited_at\" != ?", v)}
}
func (blogPostEditedAtFilter) Before(v time.Time) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"edited_at\" < ?", v)}
}

type blogPostImageFilter struct{}

func (blogPostImageFilter) HasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" LIKE ? || '%'", v)}
}
func (blogPostImageFilter) IHasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" ILIKE ? || '%'", v)}
}
func (blogPostImageFilter) NotEq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" != ?", v)}
}
func (blogPostImageFilter) Gte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" >= ?", v)}
}
func (blogPostImageFilter) Lte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" <= ?", v)}
}
func (blogPostImageFilter) Gt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" > ?", v)}
}
func (blogPostImageFilter) Lt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" < ?", v)}
}
func (blogPostImageFilter) HasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" LIKE '%' || ?", v)}
}
func (blogPostImageFilter) IContains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" ILIKE '%' || ? || '%'", v)}
}
func (blogPostImageFilter) Regex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" ~ ?", v)}
}
func (blogPostImageFilter) IRegex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" ~* ?", v)}
}
func (blogPostImageFilter) IHasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" ILIKE '%' || ?", v)}
}
func (blogPostImageFilter) Eq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" = ?", v)}
}
func (blogPostImageFilter) ILike(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" LIKE ?", v)}
}
func (blogPostImageFilter) Contains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"image\" LIKE '%' || ? || '%'", v)}
}

type blogPostPublishedFilter struct{}

func (blogPostPublishedFilter) Eq(v bool) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"published\" = ?", v)}
}
func (blogPostPublishedFilter) True() (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"published\" = ?", true)}
}
func (blogPostPublishedFilter) False() (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"published\" = ?", false)}
}
func (blogPostPublishedFilter) NotEq(v bool) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"published\" != ?", v)}
}

type blogPostScoreFilter struct{}

func (blogPostScoreFilter) Eq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"score\" = ?", v)}
}
func (blogPostScoreFilter) NotEq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"score\" != ?", v)}
}
func (blogPostScoreFilter) Lt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"score\" < ?", v)}
}
func (blogPostScoreFilter) Lte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"score\" <= ?", v)}
}
func (blogPostScoreFilter) Gt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"score\" > ?", v)}
}
func (blogPostScoreFilter) Gte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"score\" >= ?", v)}
}

type blogPostSharesFilter struct{}

func (blogPostSharesFilter) Lte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"shares\" <= ?", v)}
}
func (blogPostSharesFilter) Gt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"shares\" > ?", v)}
}
func (blogPostSharesFilter) Gte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"shares\" >= ?", v)}
}
func (blogPostSharesFilter) Eq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"shares\" = ?", v)}
}
func (blogPostSharesFilter) NotEq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"shares\" != ?", v)}
}
func (blogPostSharesFilter) Lt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"shares\" < ?", v)}
}

type blogPostSlugFilter struct{}

func (blogPostSlugFilter) NotEq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" != ?", v)}
}
func (blogPostSlugFilter) Contains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" LIKE '%' || ? || '%'", v)}
}
func (blogPostSlugFilter) Lt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" < ?", v)}
}
func (blogPostSlugFilter) Regex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" ~ ?", v)}
}
func (blogPostSlugFilter) Gt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" > ?", v)}
}
func (blogPostSlugFilter) HasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" LIKE ? || '%'", v)}
}
func (blogPostSlugFilter) Eq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" = ?", v)}
}
func (blogPostSlugFilter) IContains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" ILIKE '%' || ? || '%'", v)}
}
func (blogPostSlugFilter) Lte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" <= ?", v)}
}
func (blogPostSlugFilter) HasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" LIKE '%' || ?", v)}
}
func (blogPostSlugFilter) IHasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" ILIKE ? || '%'", v)}
}
func (blogPostSlugFilter) ILike(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" LIKE ?", v)}
}
func (blogPostSlugFilter) IRegex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" ~* ?", v)}
}
func (blogPostSlugFilter) Gte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" >= ?", v)}
}
func (blogPostSlugFilter) IHasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"slug\" ILIKE '%' || ?", v)}
}

type blogPostStageFilter struct{}

func (blogPostStageFilter) Lte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"stage\" <= ?", v)}
}
func (blogPostStageFilter) Gt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"stage\" > ?", v)}
}
func (blogPostStageFilter) Gte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"stage\" >= ?", v)}
}
func (blogPostStageFilter) Eq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"stage\" = ?", v)}
}
func (blogPostStageFilter) NotEq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"stage\" != ?", v)}
}
func (blogPostStageFilter) Lt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"stage\" < ?", v)}
}

type blogPostTitleFilter struct{}

func (blogPostTitleFilter) Gt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" > ?", v)}
}
func (blogPostTitleFilter) Contains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" LIKE '%' || ? || '%'", v)}
}
func (blogPostTitleFilter) Gte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" >= ?", v)}
}
func (blogPostTitleFilter) Eq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" = ?", v)}
}
func (blogPostTitleFilter) ILike(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" LIKE ?", v)}
}
func (blogPostTitleFilter) IRegex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" ~* ?", v)}
}
func (blogPostTitleFilter) Lt(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" < ?", v)}
}
func (blogPostTitleFilter) HasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" LIKE '%' || ?", v)}
}
func (blogPostTitleFilter) IHasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" ILIKE ? || '%'", v)}
}
func (blogPostTitleFilter) IHasSuffix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" ILIKE '%' || ?", v)}
}
func (blogPostTitleFilter) NotEq(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" != ?", v)}
}
func (blogPostTitleFilter) IContains(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" ILIKE '%' || ? || '%'", v)}
}
func (blogPostTitleFilter) Regex(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" ~ ?", v)}
}
func (blogPostTitleFilter) Lte(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" <= ?", v)}
}
func (blogPostTitleFilter) HasPrefix(v string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"title\" LIKE ? || '%'", v)}
}

type blogPostUnlistedFilter struct{}

func (blogPostUnlistedFilter) Eq(v bool) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"unlisted\" = ?", v)}
}
func (blogPostUnlistedFilter) True() (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"unlisted\" = ?", true)}
}
func (blogPostUnlistedFilter) False() (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"unlisted\" = ?", false)}
}
func (blogPostUnlistedFilter) NotEq(v bool) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"unlisted\" != ?", v)}
}

type blogPostViewsFilter struct{}

func (blogPostViewsFilter) Eq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"views\" = ?", v)}
}
func (blogPostViewsFilter) NotEq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"views\" != ?", v)}
}
func (blogPostViewsFilter) Lt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"views\" < ?", v)}
}
func (blogPostViewsFilter) Lte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"views\" <= ?", v)}
}
func (blogPostViewsFilter) Gt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"views\" > ?", v)}
}
func (blogPostViewsFilter) Gte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"views\" >= ?", v)}
}

type blogPostVotesTotalFilter struct{}

func (blogPostVotesTotalFilter) Eq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_total\" = ?", v)}
}
func (blogPostVotesTotalFilter) NotEq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_total\" != ?", v)}
}
func (blogPostVotesTotalFilter) Lt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_total\" < ?", v)}
}
func (blogPostVotesTotalFilter) Lte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_total\" <= ?", v)}
}
func (blogPostVotesTotalFilter) Gt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_total\" > ?", v)}
}
func (blogPostVotesTotalFilter) Gte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_total\" >= ?", v)}
}

type blogPostVotesUsersFilter struct{}

func (blogPostVotesUsersFilter) Gte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_users\" >= ?", v)}
}
func (blogPostVotesUsersFilter) Eq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_users\" = ?", v)}
}
func (blogPostVotesUsersFilter) NotEq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_users\" != ?", v)}
}
func (blogPostVotesUsersFilter) Lt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_users\" < ?", v)}
}
func (blogPostVotesUsersFilter) Lte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_users\" <= ?", v)}
}
func (blogPostVotesUsersFilter) Gt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"votes_users\" > ?", v)}
}

type blogPostTagsFilter struct{}

func (blogPostTagsFilter) Contains(v []string) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"tags\" @> ?", pq.Array(v))}
}

type blogPostDonationsFilter struct{}

func (blogPostDonationsFilter) NotEq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"donations\" != ?", v)}
}
func (blogPostDonationsFilter) Lt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"donations\" < ?", v)}
}
func (blogPostDonationsFilter) Lte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"donations\" <= ?", v)}
}
func (blogPostDonationsFilter) Gt(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"donations\" > ?", v)}
}
func (blogPostDonationsFilter) Gte(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"donations\" >= ?", v)}
}
func (blogPostDonationsFilter) Eq(v int64) (filter blogPostFilterArg) {
	return blogPostFilterArg{filter: sq.Expr("\"blog_posts\".\"donations\" = ?", v)}
}

type blogPostFilters struct {
	ID         blogPostIDFilter
	CreatedAt  blogPostCreatedAtFilter
	UpdatedAt  blogPostUpdatedAtFilter
	UserID     blogPostUserIDFilter
	Content    blogPostContentFilter
	Date       blogPostDateFilter
	EditedAt   blogPostEditedAtFilter
	Image      blogPostImageFilter
	Published  blogPostPublishedFilter
	Score      blogPostScoreFilter
	Shares     blogPostSharesFilter
	Slug       blogPostSlugFilter
	Stage      blogPostStageFilter
	Title      blogPostTitleFilter
	Unlisted   blogPostUnlistedFilter
	Views      blogPostViewsFilter
	VotesTotal blogPostVotesTotalFilter
	VotesUsers blogPostVotesUsersFilter
	Tags       blogPostTagsFilter
	Donations  blogPostDonationsFilter
}

// And combines multiple filters into one
func (blogPostFilters) And(filter ...blogPostFilterArg) blogPostFilterArg {
	q := sq.And{}
	j := make([]string, 0)

	for _, f := range filter {
		q = append(q, f.filter)
		j = append(j, f.joins...)
	}

	return blogPostFilterArg{
		filter: q,
		joins:  j,
	}
}

// Or combines multiple filters into one
func (blogPostFilters) Or(filter ...blogPostFilterArg) blogPostFilterArg {
	q := sq.Or{}
	j := make([]string, 0)

	for _, f := range filter {
		q = append(q, f.filter)
		j = append(j, f.joins...)
	}

	return blogPostFilterArg{
		filter: q,
		joins:  j,
	}
}

// NewsletterSubscriber represents a row in the "newsletter_subscribers" table
type NewsletterSubscriber struct {
	ID           string    `json:"id"`           // id VARCHAR(25) PRIMARY KEY
	CreatedAt    time.Time `json:"createdAt"`    // created_at TIMESTAMP WITH TIME ZONE NOT NULL
	UpdatedAt    time.Time `json:"updatedAt"`    // updated_at TIMESTAMP WITH TIME ZONE NOT NULL
	Email        string    `json:"email"`        // email TEXT NOT NULL UNIQUE
	Name         string    `json:"name"`         // name TEXT NOT NULL
	Unsubscribed bool      `json:"unsubscribed"` // unsubscribed BOOLEAN NOT NULL
}

// NewNewsletterSubscriber returns a new instance of NewsletterSubscriber with default values
func NewNewsletterSubscriber() *NewsletterSubscriber {
	return &NewsletterSubscriber{
		CreatedAt:    time.Time{},
		Email:        "",
		ID:           "",
		Name:         "",
		Unsubscribed: false,
		UpdatedAt:    time.Time{},
	}
}

// PrintJSON prints out a JSON string of the model for debugging
func (model *NewsletterSubscriber) PrintJSON() {
	b, err := json.MarshalIndent(model, "// ", "  ")
	if err != nil {
		panic(err)
	}

	fmt.Printf("\n// var %s %T = %s\n\n", "newsletterSubscriber", model, b)
}

type NewsletterSubscriberConfig struct {
	// HookPreInsert sets a hook for the model that will
	// be called before the model is inserted into the database.
	HookPreInsert func(m *NewsletterSubscriber)

	// HookPostInsert sets a hook for the model that will
	// be called after the model is inserted into the database.
	HookPostInsert func(m *NewsletterSubscriber)

	// HookPreUpdate sets a hook for the model that will
	// be called before the model is updated into the database.
	HookPreUpdate func(m *NewsletterSubscriber)

	// HookPostUpdate sets a hook for the model that will
	// be called after the model is updated into the database.
	HookPostUpdate func(m *NewsletterSubscriber)

	// HookPreDelete sets a hook for the model that will
	// be called before the model is deleted into the database.
	HookPreDelete func(m *NewsletterSubscriber)

	// HookPostDelete sets a hook for the model that will
	// be called after the model is deleted into the database.
	HookPostDelete func(m *NewsletterSubscriber)
}
type newsletterSubscriberManager struct {
	db          *sql.DB
	storeConfig StoreConfig
	config      NewsletterSubscriberConfig
}

func newNewsletterSubscriberManager(db *sql.DB, storeConfig StoreConfig, config NewsletterSubscriberConfig) *newsletterSubscriberManager {
	return &newsletterSubscriberManager{
		config:      config,
		db:          db,
		storeConfig: storeConfig,
	}
}
func (mgr *newsletterSubscriberManager) Filter(filter ...newsletterSubscriberFilterArg) *newsletterSubscriberQueryset {
	v := newNewsletterSubscriberQueryset(mgr)
	v.Filter(filter...)
	return v
}
func (mgr *newsletterSubscriberManager) Exclude(exclude ...newsletterSubscriberFilterArg) *newsletterSubscriberQueryset {
	v := newNewsletterSubscriberQueryset(mgr)
	v.Exclude(exclude...)
	return v
}
func (mgr *newsletterSubscriberManager) Delete(m *NewsletterSubscriber) error {
	// Call hook if provided
	if mgr.config.HookPreDelete != nil {
		mgr.config.HookPreDelete(m)
	}

	// Call delete on queryset with PK as the filter
	err := mgr.Filter(newsletterSubscriberFilterArg{filter: &sq.Eq{"id": m.ID}}).Delete()
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostDelete != nil {
		mgr.config.HookPostDelete(m)
	}

	return nil
}
func (mgr *newsletterSubscriberManager) DeleteP(m *NewsletterSubscriber) {
	err := mgr.Delete(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *newsletterSubscriberManager) Insert(set ...newsletterSubscriberSetterArg) (*NewsletterSubscriber, error) {
	m := mgr.newModel(set...)
	err := mgr.insertInstance(m)
	if err != nil {
		return nil, err
	}
	return m, err
}
func (mgr *newsletterSubscriberManager) InsertP(set ...newsletterSubscriberSetterArg) *NewsletterSubscriber {
	v, err := mgr.Insert(set...)
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *newsletterSubscriberManager) Validate(m *NewsletterSubscriber) error {
	if m.ID == "" {
		return errors.New("NewsletterSubscriber.ID cannot be blank")
	}
	if m.Email == "" {
		return errors.New("NewsletterSubscriber.Email cannot be blank")
	}
	return nil
}
func (mgr *newsletterSubscriberManager) ValidateP(m *NewsletterSubscriber) {
	err := mgr.Validate(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *newsletterSubscriberManager) insertInstance(m *NewsletterSubscriber) error {
	// Call hook if provided
	if mgr.config.HookPreInsert != nil {
		mgr.config.HookPreInsert(m)
	}

	err := mgr.Validate(m)
	if err != nil {
		return err
	}

	query := sq.Insert("newsletter_subscribers")
	query = query.Columns(
		"id",
		"created_at",
		"updated_at",
		"email",
		"name",
		"unsubscribed")

	query = query.Values(
		m.ID,
		m.CreatedAt,
		m.UpdatedAt,
		m.Email,
		m.Name,
		m.Unsubscribed)

	query = query.Suffix("RETURNING \"id\"")
	q, args := mgr.toSQL(query)
	result := mgr.db.QueryRow(q, args...)

	err = result.Scan(&m.ID)
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostInsert != nil {
		mgr.config.HookPostInsert(m)
	}

	return nil
}
func (mgr *newsletterSubscriberManager) Update(m *NewsletterSubscriber) error {
	// Call hook if provided
	if mgr.config.HookPreUpdate != nil {
		mgr.config.HookPreUpdate(m)
	}

	// Call update on queryset with PK as the filter
	err := mgr.Filter(newsletterSubscriberFilterArg{filter: &sq.Eq{"id": m.ID}}).Update(newsletterSubscriberSetterArg{
		field: "id",
		value: m.ID,
	}, newsletterSubscriberSetterArg{
		field: "created_at",
		value: m.CreatedAt,
	}, newsletterSubscriberSetterArg{
		field: "updated_at",
		value: m.UpdatedAt,
	}, newsletterSubscriberSetterArg{
		field: "email",
		value: m.Email,
	}, newsletterSubscriberSetterArg{
		field: "name",
		value: m.Name,
	}, newsletterSubscriberSetterArg{
		field: "unsubscribed",
		value: m.Unsubscribed,
	})
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostUpdate != nil {
		mgr.config.HookPostUpdate(m)
	}

	return nil
}
func (mgr *newsletterSubscriberManager) UpdateP(m *NewsletterSubscriber) {
	err := mgr.Update(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *newsletterSubscriberManager) All() ([]NewsletterSubscriber, error) {
	return mgr.Filter().All()
}
func (mgr *newsletterSubscriberManager) AllP() []NewsletterSubscriber {
	v, err := mgr.All()
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *newsletterSubscriberManager) None() ([]NewsletterSubscriber, error) {
	return make([]NewsletterSubscriber, 0), nil
}
func (mgr *newsletterSubscriberManager) NoneP() []NewsletterSubscriber {
	v, err := mgr.None()
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *newsletterSubscriberManager) Get(id string) (*NewsletterSubscriber, error) {
	return mgr.Filter(newsletterSubscriberFilterArg{filter: sq.Eq{"\"newsletter_subscribers\".\"id\"": id}}).One()
}
func (mgr *newsletterSubscriberManager) GetP(id string) *NewsletterSubscriber {
	v, err := mgr.Get(id)
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *newsletterSubscriberManager) newModel(set ...newsletterSubscriberSetterArg) *NewsletterSubscriber {
	m := NewNewsletterSubscriber()

	// Apply setters to default struct
	for _, s := range set {
		switch s.field {
		case "id":
			m.ID = s.value.(string)
		case "created_at":
			m.CreatedAt = s.value.(time.Time)
		case "updated_at":
			m.UpdatedAt = s.value.(time.Time)
		case "email":
			m.Email = s.value.(string)
		case "name":
			m.Name = s.value.(string)
		case "unsubscribed":
			m.Unsubscribed = s.value.(bool)
		default:
			panic("invalid field for setter: " + s.field)
		}
	}

	return m
}
func (mgr *newsletterSubscriberManager) toSQL(q sq.Sqlizer) (string, []interface{}) {
	query, args, err := q.ToSql()
	if err != nil {
		panic(err)
	}

	query, err = sq.Dollar.ReplacePlaceholders(query)
	if err != nil {
		panic(err)
	}

	return query, args
}

type newsletterSubscriberQueryset struct {
	mgr     *newsletterSubscriberManager
	filter  []newsletterSubscriberFilterArg
	orderBy []newsletterSubscriberOrderByArg
	limit   uint64
	offset  uint64
}

func newNewsletterSubscriberQueryset(mgr *newsletterSubscriberManager) *newsletterSubscriberQueryset {
	return &newsletterSubscriberQueryset{
		filter:  make([]newsletterSubscriberFilterArg, 0),
		limit:   0,
		mgr:     mgr,
		offset:  0,
		orderBy: make([]newsletterSubscriberOrderByArg, 0),
	}
}
func (qs *newsletterSubscriberQueryset) Filter(filter ...newsletterSubscriberFilterArg) *newsletterSubscriberQueryset {
	qs.filter = append(qs.filter, filter...)
	return qs
}
func (qs *newsletterSubscriberQueryset) Exclude(exclude ...newsletterSubscriberFilterArg) *newsletterSubscriberQueryset {
	q := sq.And{}
	j := make([]string, 0)
	for _, e := range exclude {
		q = append(q, e.filter)
		j = append(j, e.joins...)
	}

	qs.filter = append(qs.filter, newsletterSubscriberFilterArg{
		filter: sq.ConcatExpr("NOT", q),
		joins:  j,
	})

	return qs
}
func (qs *newsletterSubscriberQueryset) Sort(orderBy ...newsletterSubscriberOrderByArg) *newsletterSubscriberQueryset {
	qs.orderBy = append(qs.orderBy, orderBy...)
	return qs
}
func (qs *newsletterSubscriberQueryset) Limit(limit uint64) *newsletterSubscriberQueryset {
	qs.limit = limit
	return qs
}
func (qs *newsletterSubscriberQueryset) Offset(offset uint64) *newsletterSubscriberQueryset {
	qs.offset = offset
	return qs
}
func (qs *newsletterSubscriberQueryset) Update(set ...newsletterSubscriberSetterArg) error {
	query := sq.Update("newsletter_subscribers")

	// Apply setters to query
	for _, s := range set {
		query = query.Set(s.field, s.value)
	}

	// Apply filters to query
	for _, f := range qs.filter {
		query = query.Where(f.filter)
	}

	q, args := qs.toSQL(query)
	_, err := qs.mgr.db.Exec(q, args...)
	return err
}
func (qs *newsletterSubscriberQueryset) UpdateP(set ...newsletterSubscriberSetterArg) {
	err := qs.Update(set...)
	if err != nil {
		panic(err)
	}
}
func (qs *newsletterSubscriberQueryset) All() ([]NewsletterSubscriber, error) {
	query := qs.starSelect()
	q, args := qs.toSQL(query)

	rows, err := qs.mgr.db.Query(q, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := make([]NewsletterSubscriber, 0)

	for rows.Next() {
		var m NewsletterSubscriber
		err = qs.scan(rows, &m)
		if err != nil {
			return nil, err
		}
		items = append(items, m)
	}

	return items, err
}
func (qs *newsletterSubscriberQueryset) AllP() []NewsletterSubscriber {
	v, err := qs.All()
	if err != nil {
		panic(err)
	}
	return v
}
func (qs *newsletterSubscriberQueryset) One() (*NewsletterSubscriber, error) {
	items, err := qs.All()

	// Ensure we have a result
	if len(items) == 0 {
		return nil, sql.ErrNoRows
	}

	return &items[0], err
}
func (qs *newsletterSubscriberQueryset) OneP() *NewsletterSubscriber {
	v, err := qs.One()
	if err != nil {
		panic(err)
	}
	return v
}
func (qs *newsletterSubscriberQueryset) Delete() error {
	query := sq.Delete("newsletter_subscribers")

	for _, w := range qs.filter {
		query = query.Where(w.filter)
	}

	q, args := qs.toSQL(query)
	_, err := qs.mgr.db.Exec(q, args...)
	return err
}
func (qs *newsletterSubscriberQueryset) DeleteP() {
	err := qs.Delete()
	if err != nil {
		panic(err)
	}
}
func (qs *newsletterSubscriberQueryset) scan(r *sql.Rows, m *NewsletterSubscriber) error {
	return r.Scan(
		&m.ID,
		&m.CreatedAt,
		&m.UpdatedAt,
		&m.Email,
		&m.Name,
		&m.Unsubscribed)
}
func (qs *newsletterSubscriberQueryset) starSelect() sq.SelectBuilder {
	query := sq.Select(
		"\"newsletter_subscribers\".\"id\"",
		"\"newsletter_subscribers\".\"created_at\"",
		"\"newsletter_subscribers\".\"updated_at\"",
		"\"newsletter_subscribers\".\"email\"",
		"\"newsletter_subscribers\".\"name\"",
		"\"newsletter_subscribers\".\"unsubscribed\"").From("newsletter_subscribers")

	joinCheck := make(map[string]bool)

	// Assign filters and join if necessary
	for _, w := range qs.filter {
		query = query.Where(w.filter)
		for _, j := range w.joins {
			if _, ok := joinCheck[j]; ok {
				continue
			}
			joinCheck[j] = true
			query = query.Join(j)
		}
	}

	// Apply limit if set
	if qs.limit > 0 {
		query = query.Limit(qs.limit)
	}

	// Apply offset if set
	if qs.offset > 0 {
		query = query.Offset(qs.offset)
	}

	// Apply default order if none specified
	if len(qs.orderBy) == 0 {
		// TODO: Add default order-by
	}

	// Apply user-specified order
	for _, s := range qs.orderBy {
		query = query.OrderBy(s.field + " " + s.order)
	}

	return query
}
func (qs *newsletterSubscriberQueryset) toSQL(q sq.Sqlizer) (string, []interface{}) {
	return qs.mgr.toSQL(q)
}

type newsletterSubscriberFilterArg struct {
	filter sq.Sqlizer
	joins  []string
}
type newsletterSubscriberOrderByArg struct {
	field string
	order string
	join  string
}
type newsletterSubscriberSetterArg struct {
	field string
	value interface{}
}
type newsletterSubscriberSetters struct{}

// ID sets the "id" field to the provided value.
func (newsletterSubscriberSetters) ID(v string) newsletterSubscriberSetterArg {
	return newsletterSubscriberSetterArg{
		field: "id",
		value: v,
	}
}

// CreatedAt sets the "created_at" field to the provided value.
func (newsletterSubscriberSetters) CreatedAt(v time.Time) newsletterSubscriberSetterArg {
	return newsletterSubscriberSetterArg{
		field: "created_at",
		value: v,
	}
}

// UpdatedAt sets the "updated_at" field to the provided value.
func (newsletterSubscriberSetters) UpdatedAt(v time.Time) newsletterSubscriberSetterArg {
	return newsletterSubscriberSetterArg{
		field: "updated_at",
		value: v,
	}
}

// Email sets the "email" field to the provided value.
func (newsletterSubscriberSetters) Email(v string) newsletterSubscriberSetterArg {
	return newsletterSubscriberSetterArg{
		field: "email",
		value: v,
	}
}

// Name sets the "name" field to the provided value.
func (newsletterSubscriberSetters) Name(v string) newsletterSubscriberSetterArg {
	return newsletterSubscriberSetterArg{
		field: "name",
		value: v,
	}
}

// Unsubscribed sets the "unsubscribed" field to the provided value.
func (newsletterSubscriberSetters) Unsubscribed(v bool) newsletterSubscriberSetterArg {
	return newsletterSubscriberSetterArg{
		field: "unsubscribed",
		value: v,
	}
}

type newsletterSubscriberOrders struct {
	ID           newsletterSubscriberIDOrderByArg
	CreatedAt    newsletterSubscriberCreatedAtOrderByArg
	UpdatedAt    newsletterSubscriberUpdatedAtOrderByArg
	Email        newsletterSubscriberEmailOrderByArg
	Name         newsletterSubscriberNameOrderByArg
	Unsubscribed newsletterSubscriberUnsubscribedOrderByArg
}

type newsletterSubscriberIDOrderByArg struct {
	// Asc orders results in ascending direction
	Asc newsletterSubscriberOrderByArg

	// Desc orders results in descending direction
	Desc newsletterSubscriberOrderByArg
}

type newsletterSubscriberCreatedAtOrderByArg struct {
	// Asc orders results in ascending direction
	Asc newsletterSubscriberOrderByArg

	// Desc orders results in descending direction
	Desc newsletterSubscriberOrderByArg
}

type newsletterSubscriberUpdatedAtOrderByArg struct {
	// Asc orders results in ascending direction
	Asc newsletterSubscriberOrderByArg

	// Desc orders results in descending direction
	Desc newsletterSubscriberOrderByArg
}

type newsletterSubscriberEmailOrderByArg struct {
	// Asc orders results in ascending direction
	Asc newsletterSubscriberOrderByArg

	// Desc orders results in descending direction
	Desc newsletterSubscriberOrderByArg
}

type newsletterSubscriberNameOrderByArg struct {
	// Asc orders results in ascending direction
	Asc newsletterSubscriberOrderByArg

	// Desc orders results in descending direction
	Desc newsletterSubscriberOrderByArg
}

type newsletterSubscriberUnsubscribedOrderByArg struct {
	// Asc orders results in ascending direction
	Asc newsletterSubscriberOrderByArg

	// Desc orders results in descending direction
	Desc newsletterSubscriberOrderByArg
}

func newNewsletterSubscriberOrders() newsletterSubscriberOrders {
	return newsletterSubscriberOrders{
		CreatedAt: newsletterSubscriberCreatedAtOrderByArg{
			Asc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"created_at\"",
				join:  "",
				order: "ASC",
			},
			Desc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"created_at\"",
				join:  "",
				order: "DESC",
			},
		},
		Email: newsletterSubscriberEmailOrderByArg{
			Asc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"email\"",
				join:  "",
				order: "ASC",
			},
			Desc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"email\"",
				join:  "",
				order: "DESC",
			},
		},
		ID: newsletterSubscriberIDOrderByArg{
			Asc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"id\"",
				join:  "",
				order: "ASC",
			},
			Desc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"id\"",
				join:  "",
				order: "DESC",
			},
		},
		Name: newsletterSubscriberNameOrderByArg{
			Asc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"name\"",
				join:  "",
				order: "ASC",
			},
			Desc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"name\"",
				join:  "",
				order: "DESC",
			},
		},
		Unsubscribed: newsletterSubscriberUnsubscribedOrderByArg{
			Asc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"unsubscribed\"",
				join:  "",
				order: "ASC",
			},
			Desc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"unsubscribed\"",
				join:  "",
				order: "DESC",
			},
		},
		UpdatedAt: newsletterSubscriberUpdatedAtOrderByArg{
			Asc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"updated_at\"",
				join:  "",
				order: "ASC",
			},
			Desc: newsletterSubscriberOrderByArg{
				field: "\"newsletter_subscribers\".\"updated_at\"",
				join:  "",
				order: "DESC",
			},
		},
	}
}

type newsletterSubscriberIDFilter struct{}

func (newsletterSubscriberIDFilter) Gt(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" > ?", v)}
}
func (newsletterSubscriberIDFilter) Lt(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" < ?", v)}
}
func (newsletterSubscriberIDFilter) HasPrefix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" LIKE ? || '%'", v)}
}
func (newsletterSubscriberIDFilter) IHasPrefix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" ILIKE ? || '%'", v)}
}
func (newsletterSubscriberIDFilter) Eq(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" = ?", v)}
}
func (newsletterSubscriberIDFilter) Regex(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" ~ ?", v)}
}
func (newsletterSubscriberIDFilter) IRegex(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" ~* ?", v)}
}
func (newsletterSubscriberIDFilter) Lte(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" <= ?", v)}
}
func (newsletterSubscriberIDFilter) NotEq(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" != ?", v)}
}
func (newsletterSubscriberIDFilter) Contains(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" LIKE '%' || ? || '%'", v)}
}
func (newsletterSubscriberIDFilter) IContains(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" ILIKE '%' || ? || '%'", v)}
}
func (newsletterSubscriberIDFilter) HasSuffix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" LIKE '%' || ?", v)}
}
func (newsletterSubscriberIDFilter) IHasSuffix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" ILIKE '%' || ?", v)}
}
func (newsletterSubscriberIDFilter) ILike(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" LIKE ?", v)}
}
func (newsletterSubscriberIDFilter) Gte(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"id\" >= ?", v)}
}

type newsletterSubscriberCreatedAtFilter struct{}

func (newsletterSubscriberCreatedAtFilter) Eq(v time.Time) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"created_at\" = ?", v)}
}
func (newsletterSubscriberCreatedAtFilter) NotEq(v time.Time) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"created_at\" != ?", v)}
}
func (newsletterSubscriberCreatedAtFilter) Before(v time.Time) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"created_at\" < ?", v)}
}
func (newsletterSubscriberCreatedAtFilter) After(v time.Time) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"created_at\" > ?", v)}
}

type newsletterSubscriberUpdatedAtFilter struct{}

func (newsletterSubscriberUpdatedAtFilter) Eq(v time.Time) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"updated_at\" = ?", v)}
}
func (newsletterSubscriberUpdatedAtFilter) NotEq(v time.Time) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"updated_at\" != ?", v)}
}
func (newsletterSubscriberUpdatedAtFilter) Before(v time.Time) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"updated_at\" < ?", v)}
}
func (newsletterSubscriberUpdatedAtFilter) After(v time.Time) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"updated_at\" > ?", v)}
}

type newsletterSubscriberEmailFilter struct{}

func (newsletterSubscriberEmailFilter) IContains(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" ILIKE '%' || ? || '%'", v)}
}
func (newsletterSubscriberEmailFilter) Gte(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" >= ?", v)}
}
func (newsletterSubscriberEmailFilter) Eq(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" = ?", v)}
}
func (newsletterSubscriberEmailFilter) IRegex(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" ~* ?", v)}
}
func (newsletterSubscriberEmailFilter) IHasSuffix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" ILIKE '%' || ?", v)}
}
func (newsletterSubscriberEmailFilter) NotEq(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" != ?", v)}
}
func (newsletterSubscriberEmailFilter) Lte(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" <= ?", v)}
}
func (newsletterSubscriberEmailFilter) HasPrefix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" LIKE ? || '%'", v)}
}
func (newsletterSubscriberEmailFilter) IHasPrefix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" ILIKE ? || '%'", v)}
}
func (newsletterSubscriberEmailFilter) Gt(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" > ?", v)}
}
func (newsletterSubscriberEmailFilter) Contains(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" LIKE '%' || ? || '%'", v)}
}
func (newsletterSubscriberEmailFilter) Regex(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" ~ ?", v)}
}
func (newsletterSubscriberEmailFilter) Lt(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" < ?", v)}
}
func (newsletterSubscriberEmailFilter) HasSuffix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" LIKE '%' || ?", v)}
}
func (newsletterSubscriberEmailFilter) ILike(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"email\" LIKE ?", v)}
}

type newsletterSubscriberNameFilter struct{}

func (newsletterSubscriberNameFilter) IContains(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" ILIKE '%' || ? || '%'", v)}
}
func (newsletterSubscriberNameFilter) Regex(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" ~ ?", v)}
}
func (newsletterSubscriberNameFilter) Gte(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" >= ?", v)}
}
func (newsletterSubscriberNameFilter) IHasSuffix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" ILIKE '%' || ?", v)}
}
func (newsletterSubscriberNameFilter) Lte(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" <= ?", v)}
}
func (newsletterSubscriberNameFilter) ILike(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" LIKE ?", v)}
}
func (newsletterSubscriberNameFilter) NotEq(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" != ?", v)}
}
func (newsletterSubscriberNameFilter) Contains(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" LIKE '%' || ? || '%'", v)}
}
func (newsletterSubscriberNameFilter) IRegex(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" ~* ?", v)}
}
func (newsletterSubscriberNameFilter) Lt(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" < ?", v)}
}
func (newsletterSubscriberNameFilter) Gt(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" > ?", v)}
}
func (newsletterSubscriberNameFilter) HasPrefix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" LIKE ? || '%'", v)}
}
func (newsletterSubscriberNameFilter) Eq(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" = ?", v)}
}
func (newsletterSubscriberNameFilter) HasSuffix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" LIKE '%' || ?", v)}
}
func (newsletterSubscriberNameFilter) IHasPrefix(v string) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"name\" ILIKE ? || '%'", v)}
}

type newsletterSubscriberUnsubscribedFilter struct{}

func (newsletterSubscriberUnsubscribedFilter) Eq(v bool) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"unsubscribed\" = ?", v)}
}
func (newsletterSubscriberUnsubscribedFilter) True() (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"unsubscribed\" = ?", true)}
}
func (newsletterSubscriberUnsubscribedFilter) False() (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"unsubscribed\" = ?", false)}
}
func (newsletterSubscriberUnsubscribedFilter) NotEq(v bool) (filter newsletterSubscriberFilterArg) {
	return newsletterSubscriberFilterArg{filter: sq.Expr("\"newsletter_subscribers\".\"unsubscribed\" != ?", v)}
}

type newsletterSubscriberFilters struct {
	ID           newsletterSubscriberIDFilter
	CreatedAt    newsletterSubscriberCreatedAtFilter
	UpdatedAt    newsletterSubscriberUpdatedAtFilter
	Email        newsletterSubscriberEmailFilter
	Name         newsletterSubscriberNameFilter
	Unsubscribed newsletterSubscriberUnsubscribedFilter
}

// And combines multiple filters into one
func (newsletterSubscriberFilters) And(filter ...newsletterSubscriberFilterArg) newsletterSubscriberFilterArg {
	q := sq.And{}
	j := make([]string, 0)

	for _, f := range filter {
		q = append(q, f.filter)
		j = append(j, f.joins...)
	}

	return newsletterSubscriberFilterArg{
		filter: q,
		joins:  j,
	}
}

// Or combines multiple filters into one
func (newsletterSubscriberFilters) Or(filter ...newsletterSubscriberFilterArg) newsletterSubscriberFilterArg {
	q := sq.Or{}
	j := make([]string, 0)

	for _, f := range filter {
		q = append(q, f.filter)
		j = append(j, f.joins...)
	}

	return newsletterSubscriberFilterArg{
		filter: q,
		joins:  j,
	}
}

// Session represents a row in the "sessions" table
type Session struct {
	ID        string    `json:"id"`        // id VARCHAR(25) PRIMARY KEY
	CreatedAt time.Time `json:"createdAt"` // created_at TIMESTAMP WITH TIME ZONE NOT NULL
	UserID    string    `json:"userId"`    // user_id VARCHAR(25) NOT NULL
}

// NewSession returns a new instance of Session with default values
func NewSession() *Session {
	return &Session{
		CreatedAt: time.Time{},
		ID:        "",
		UserID:    "",
	}
}

// PrintJSON prints out a JSON string of the model for debugging
func (model *Session) PrintJSON() {
	b, err := json.MarshalIndent(model, "// ", "  ")
	if err != nil {
		panic(err)
	}

	fmt.Printf("\n// var %s %T = %s\n\n", "session", model, b)
}

type SessionConfig struct {
	// HookPreInsert sets a hook for the model that will
	// be called before the model is inserted into the database.
	HookPreInsert func(m *Session)

	// HookPostInsert sets a hook for the model that will
	// be called after the model is inserted into the database.
	HookPostInsert func(m *Session)

	// HookPreUpdate sets a hook for the model that will
	// be called before the model is updated into the database.
	HookPreUpdate func(m *Session)

	// HookPostUpdate sets a hook for the model that will
	// be called after the model is updated into the database.
	HookPostUpdate func(m *Session)

	// HookPreDelete sets a hook for the model that will
	// be called before the model is deleted into the database.
	HookPreDelete func(m *Session)

	// HookPostDelete sets a hook for the model that will
	// be called after the model is deleted into the database.
	HookPostDelete func(m *Session)
}
type sessionManager struct {
	db          *sql.DB
	storeConfig StoreConfig
	config      SessionConfig
}

func newSessionManager(db *sql.DB, storeConfig StoreConfig, config SessionConfig) *sessionManager {
	return &sessionManager{
		config:      config,
		db:          db,
		storeConfig: storeConfig,
	}
}
func (mgr *sessionManager) Filter(filter ...sessionFilterArg) *sessionQueryset {
	v := newSessionQueryset(mgr)
	v.Filter(filter...)
	return v
}
func (mgr *sessionManager) Exclude(exclude ...sessionFilterArg) *sessionQueryset {
	v := newSessionQueryset(mgr)
	v.Exclude(exclude...)
	return v
}
func (mgr *sessionManager) Delete(m *Session) error {
	// Call hook if provided
	if mgr.config.HookPreDelete != nil {
		mgr.config.HookPreDelete(m)
	}

	// Call delete on queryset with PK as the filter
	err := mgr.Filter(sessionFilterArg{filter: &sq.Eq{"id": m.ID}}).Delete()
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostDelete != nil {
		mgr.config.HookPostDelete(m)
	}

	return nil
}
func (mgr *sessionManager) DeleteP(m *Session) {
	err := mgr.Delete(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *sessionManager) Insert(set ...sessionSetterArg) (*Session, error) {
	m := mgr.newModel(set...)
	err := mgr.insertInstance(m)
	if err != nil {
		return nil, err
	}
	return m, err
}
func (mgr *sessionManager) InsertP(set ...sessionSetterArg) *Session {
	v, err := mgr.Insert(set...)
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *sessionManager) Validate(m *Session) error {
	if m.ID == "" {
		return errors.New("Session.ID cannot be blank")
	}
	if m.UserID == "" {
		return errors.New("Session.UserID cannot be blank")
	}
	return nil
}
func (mgr *sessionManager) ValidateP(m *Session) {
	err := mgr.Validate(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *sessionManager) insertInstance(m *Session) error {
	// Call hook if provided
	if mgr.config.HookPreInsert != nil {
		mgr.config.HookPreInsert(m)
	}

	err := mgr.Validate(m)
	if err != nil {
		return err
	}

	query := sq.Insert("sessions")
	query = query.Columns(
		"id",
		"created_at",
		"user_id")

	query = query.Values(
		m.ID,
		m.CreatedAt,
		m.UserID)

	query = query.Suffix("RETURNING \"id\"")
	q, args := mgr.toSQL(query)
	result := mgr.db.QueryRow(q, args...)

	err = result.Scan(&m.ID)
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostInsert != nil {
		mgr.config.HookPostInsert(m)
	}

	return nil
}
func (mgr *sessionManager) Update(m *Session) error {
	// Call hook if provided
	if mgr.config.HookPreUpdate != nil {
		mgr.config.HookPreUpdate(m)
	}

	// Call update on queryset with PK as the filter
	err := mgr.Filter(sessionFilterArg{filter: &sq.Eq{"id": m.ID}}).Update(sessionSetterArg{
		field: "id",
		value: m.ID,
	}, sessionSetterArg{
		field: "created_at",
		value: m.CreatedAt,
	}, sessionSetterArg{
		field: "user_id",
		value: m.UserID,
	})
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostUpdate != nil {
		mgr.config.HookPostUpdate(m)
	}

	return nil
}
func (mgr *sessionManager) UpdateP(m *Session) {
	err := mgr.Update(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *sessionManager) All() ([]Session, error) {
	return mgr.Filter().All()
}
func (mgr *sessionManager) AllP() []Session {
	v, err := mgr.All()
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *sessionManager) None() ([]Session, error) {
	return make([]Session, 0), nil
}
func (mgr *sessionManager) NoneP() []Session {
	v, err := mgr.None()
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *sessionManager) Get(id string) (*Session, error) {
	return mgr.Filter(sessionFilterArg{filter: sq.Eq{"\"sessions\".\"id\"": id}}).One()
}
func (mgr *sessionManager) GetP(id string) *Session {
	v, err := mgr.Get(id)
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *sessionManager) newModel(set ...sessionSetterArg) *Session {
	m := NewSession()

	// Apply setters to default struct
	for _, s := range set {
		switch s.field {
		case "id":
			m.ID = s.value.(string)
		case "created_at":
			m.CreatedAt = s.value.(time.Time)
		case "user_id":
			m.UserID = s.value.(string)
		default:
			panic("invalid field for setter: " + s.field)
		}
	}

	return m
}
func (mgr *sessionManager) toSQL(q sq.Sqlizer) (string, []interface{}) {
	query, args, err := q.ToSql()
	if err != nil {
		panic(err)
	}

	query, err = sq.Dollar.ReplacePlaceholders(query)
	if err != nil {
		panic(err)
	}

	return query, args
}

type sessionQueryset struct {
	mgr     *sessionManager
	filter  []sessionFilterArg
	orderBy []sessionOrderByArg
	limit   uint64
	offset  uint64
}

func newSessionQueryset(mgr *sessionManager) *sessionQueryset {
	return &sessionQueryset{
		filter:  make([]sessionFilterArg, 0),
		limit:   0,
		mgr:     mgr,
		offset:  0,
		orderBy: make([]sessionOrderByArg, 0),
	}
}
func (qs *sessionQueryset) Filter(filter ...sessionFilterArg) *sessionQueryset {
	qs.filter = append(qs.filter, filter...)
	return qs
}
func (qs *sessionQueryset) Exclude(exclude ...sessionFilterArg) *sessionQueryset {
	q := sq.And{}
	j := make([]string, 0)
	for _, e := range exclude {
		q = append(q, e.filter)
		j = append(j, e.joins...)
	}

	qs.filter = append(qs.filter, sessionFilterArg{
		filter: sq.ConcatExpr("NOT", q),
		joins:  j,
	})

	return qs
}
func (qs *sessionQueryset) Sort(orderBy ...sessionOrderByArg) *sessionQueryset {
	qs.orderBy = append(qs.orderBy, orderBy...)
	return qs
}
func (qs *sessionQueryset) Limit(limit uint64) *sessionQueryset {
	qs.limit = limit
	return qs
}
func (qs *sessionQueryset) Offset(offset uint64) *sessionQueryset {
	qs.offset = offset
	return qs
}
func (qs *sessionQueryset) Update(set ...sessionSetterArg) error {
	query := sq.Update("sessions")

	// Apply setters to query
	for _, s := range set {
		query = query.Set(s.field, s.value)
	}

	// Apply filters to query
	for _, f := range qs.filter {
		query = query.Where(f.filter)
	}

	q, args := qs.toSQL(query)
	_, err := qs.mgr.db.Exec(q, args...)
	return err
}
func (qs *sessionQueryset) UpdateP(set ...sessionSetterArg) {
	err := qs.Update(set...)
	if err != nil {
		panic(err)
	}
}
func (qs *sessionQueryset) All() ([]Session, error) {
	query := qs.starSelect()
	q, args := qs.toSQL(query)

	rows, err := qs.mgr.db.Query(q, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := make([]Session, 0)

	for rows.Next() {
		var m Session
		err = qs.scan(rows, &m)
		if err != nil {
			return nil, err
		}
		items = append(items, m)
	}

	return items, err
}
func (qs *sessionQueryset) AllP() []Session {
	v, err := qs.All()
	if err != nil {
		panic(err)
	}
	return v
}
func (qs *sessionQueryset) One() (*Session, error) {
	items, err := qs.All()

	// Ensure we have a result
	if len(items) == 0 {
		return nil, sql.ErrNoRows
	}

	return &items[0], err
}
func (qs *sessionQueryset) OneP() *Session {
	v, err := qs.One()
	if err != nil {
		panic(err)
	}
	return v
}
func (qs *sessionQueryset) Delete() error {
	query := sq.Delete("sessions")

	for _, w := range qs.filter {
		query = query.Where(w.filter)
	}

	q, args := qs.toSQL(query)
	_, err := qs.mgr.db.Exec(q, args...)
	return err
}
func (qs *sessionQueryset) DeleteP() {
	err := qs.Delete()
	if err != nil {
		panic(err)
	}
}
func (qs *sessionQueryset) scan(r *sql.Rows, m *Session) error {
	return r.Scan(
		&m.ID,
		&m.CreatedAt,
		&m.UserID)
}
func (qs *sessionQueryset) starSelect() sq.SelectBuilder {
	query := sq.Select(
		"\"sessions\".\"id\"",
		"\"sessions\".\"created_at\"",
		"\"sessions\".\"user_id\"").From("sessions")

	joinCheck := make(map[string]bool)

	// Assign filters and join if necessary
	for _, w := range qs.filter {
		query = query.Where(w.filter)
		for _, j := range w.joins {
			if _, ok := joinCheck[j]; ok {
				continue
			}
			joinCheck[j] = true
			query = query.Join(j)
		}
	}

	// Apply limit if set
	if qs.limit > 0 {
		query = query.Limit(qs.limit)
	}

	// Apply offset if set
	if qs.offset > 0 {
		query = query.Offset(qs.offset)
	}

	// Apply default order if none specified
	if len(qs.orderBy) == 0 {
		// TODO: Add default order-by
	}

	// Apply user-specified order
	for _, s := range qs.orderBy {
		query = query.OrderBy(s.field + " " + s.order)
	}

	return query
}
func (qs *sessionQueryset) toSQL(q sq.Sqlizer) (string, []interface{}) {
	return qs.mgr.toSQL(q)
}

type sessionFilterArg struct {
	filter sq.Sqlizer
	joins  []string
}
type sessionOrderByArg struct {
	field string
	order string
	join  string
}
type sessionSetterArg struct {
	field string
	value interface{}
}
type sessionSetters struct{}

// ID sets the "id" field to the provided value.
func (sessionSetters) ID(v string) sessionSetterArg {
	return sessionSetterArg{
		field: "id",
		value: v,
	}
}

// CreatedAt sets the "created_at" field to the provided value.
func (sessionSetters) CreatedAt(v time.Time) sessionSetterArg {
	return sessionSetterArg{
		field: "created_at",
		value: v,
	}
}

// UserID sets the "user_id" field to the provided value.
func (sessionSetters) UserID(v string) sessionSetterArg {
	return sessionSetterArg{
		field: "user_id",
		value: v,
	}
}

type sessionOrders struct {
	ID        sessionIDOrderByArg
	CreatedAt sessionCreatedAtOrderByArg
	UserID    sessionUserIDOrderByArg
}

type sessionIDOrderByArg struct {
	// Asc orders results in ascending direction
	Asc sessionOrderByArg

	// Desc orders results in descending direction
	Desc sessionOrderByArg
}

type sessionCreatedAtOrderByArg struct {
	// Asc orders results in ascending direction
	Asc sessionOrderByArg

	// Desc orders results in descending direction
	Desc sessionOrderByArg
}

type sessionUserIDOrderByArg struct {
	// Asc orders results in ascending direction
	Asc sessionOrderByArg

	// Desc orders results in descending direction
	Desc sessionOrderByArg
}

func newSessionOrders() sessionOrders {
	return sessionOrders{
		CreatedAt: sessionCreatedAtOrderByArg{
			Asc: sessionOrderByArg{
				field: "\"sessions\".\"created_at\"",
				join:  "",
				order: "ASC",
			},
			Desc: sessionOrderByArg{
				field: "\"sessions\".\"created_at\"",
				join:  "",
				order: "DESC",
			},
		},
		ID: sessionIDOrderByArg{
			Asc: sessionOrderByArg{
				field: "\"sessions\".\"id\"",
				join:  "",
				order: "ASC",
			},
			Desc: sessionOrderByArg{
				field: "\"sessions\".\"id\"",
				join:  "",
				order: "DESC",
			},
		},
		UserID: sessionUserIDOrderByArg{
			Asc: sessionOrderByArg{
				field: "\"sessions\".\"user_id\"",
				join:  "",
				order: "ASC",
			},
			Desc: sessionOrderByArg{
				field: "\"sessions\".\"user_id\"",
				join:  "",
				order: "DESC",
			},
		},
	}
}

type sessionIDFilter struct{}

func (sessionIDFilter) Contains(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" LIKE '%' || ? || '%'", v)}
}
func (sessionIDFilter) Regex(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" ~ ?", v)}
}
func (sessionIDFilter) IHasPrefix(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" ILIKE ? || '%'", v)}
}
func (sessionIDFilter) IHasSuffix(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" ILIKE '%' || ?", v)}
}
func (sessionIDFilter) IContains(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" ILIKE '%' || ? || '%'", v)}
}
func (sessionIDFilter) IRegex(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" ~* ?", v)}
}
func (sessionIDFilter) Gte(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" >= ?", v)}
}
func (sessionIDFilter) Lt(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" < ?", v)}
}
func (sessionIDFilter) HasPrefix(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" LIKE ? || '%'", v)}
}
func (sessionIDFilter) HasSuffix(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" LIKE '%' || ?", v)}
}
func (sessionIDFilter) ILike(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" LIKE ?", v)}
}
func (sessionIDFilter) Gt(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" > ?", v)}
}
func (sessionIDFilter) Eq(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" = ?", v)}
}
func (sessionIDFilter) NotEq(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" != ?", v)}
}
func (sessionIDFilter) Lte(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"id\" <= ?", v)}
}

type sessionCreatedAtFilter struct{}

func (sessionCreatedAtFilter) Before(v time.Time) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"created_at\" < ?", v)}
}
func (sessionCreatedAtFilter) After(v time.Time) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"created_at\" > ?", v)}
}
func (sessionCreatedAtFilter) Eq(v time.Time) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"created_at\" = ?", v)}
}
func (sessionCreatedAtFilter) NotEq(v time.Time) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"created_at\" != ?", v)}
}

type sessionUserIDFilter struct{}

func (sessionUserIDFilter) ILike(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" LIKE ?", v)}
}
func (sessionUserIDFilter) IContains(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" ILIKE '%' || ? || '%'", v)}
}
func (sessionUserIDFilter) IRegex(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" ~* ?", v)}
}
func (sessionUserIDFilter) Lt(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" < ?", v)}
}
func (sessionUserIDFilter) HasPrefix(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" LIKE ? || '%'", v)}
}
func (sessionUserIDFilter) Regex(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" ~ ?", v)}
}
func (sessionUserIDFilter) Gt(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" > ?", v)}
}
func (sessionUserIDFilter) Gte(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" >= ?", v)}
}
func (sessionUserIDFilter) Eq(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" = ?", v)}
}
func (sessionUserIDFilter) NotEq(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" != ?", v)}
}
func (sessionUserIDFilter) IHasPrefix(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" ILIKE ? || '%'", v)}
}
func (sessionUserIDFilter) IHasSuffix(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" ILIKE '%' || ?", v)}
}
func (sessionUserIDFilter) Contains(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" LIKE '%' || ? || '%'", v)}
}
func (sessionUserIDFilter) Lte(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" <= ?", v)}
}
func (sessionUserIDFilter) HasSuffix(v string) (filter sessionFilterArg) {
	return sessionFilterArg{filter: sq.Expr("\"sessions\".\"user_id\" LIKE '%' || ?", v)}
}

type sessionFilters struct {
	ID        sessionIDFilter
	CreatedAt sessionCreatedAtFilter
	UserID    sessionUserIDFilter
}

// And combines multiple filters into one
func (sessionFilters) And(filter ...sessionFilterArg) sessionFilterArg {
	q := sq.And{}
	j := make([]string, 0)

	for _, f := range filter {
		q = append(q, f.filter)
		j = append(j, f.joins...)
	}

	return sessionFilterArg{
		filter: q,
		joins:  j,
	}
}

// Or combines multiple filters into one
func (sessionFilters) Or(filter ...sessionFilterArg) sessionFilterArg {
	q := sq.Or{}
	j := make([]string, 0)

	for _, f := range filter {
		q = append(q, f.filter)
		j = append(j, f.joins...)
	}

	return sessionFilterArg{
		filter: q,
		joins:  j,
	}
}

// User represents a row in the "users" table
type User struct {
	ID           string    `json:"id"`           // id VARCHAR(25) PRIMARY KEY
	CreatedAt    time.Time `json:"createdAt"`    // created_at TIMESTAMP WITH TIME ZONE NOT NULL
	Email        string    `json:"email"`        // email TEXT NOT NULL UNIQUE
	Name         string    `json:"name"`         // name TEXT NOT NULL
	PasswordHash string    `json:"passwordHash"` // password_hash TEXT NOT NULL
}

// NewUser returns a new instance of User with default values
func NewUser() *User {
	return &User{
		CreatedAt:    time.Time{},
		Email:        "",
		ID:           "",
		Name:         "",
		PasswordHash: "",
	}
}

// PrintJSON prints out a JSON string of the model for debugging
func (model *User) PrintJSON() {
	b, err := json.MarshalIndent(model, "// ", "  ")
	if err != nil {
		panic(err)
	}

	fmt.Printf("\n// var %s %T = %s\n\n", "user", model, b)
}

type UserConfig struct {
	// HookPreInsert sets a hook for the model that will
	// be called before the model is inserted into the database.
	HookPreInsert func(m *User)

	// HookPostInsert sets a hook for the model that will
	// be called after the model is inserted into the database.
	HookPostInsert func(m *User)

	// HookPreUpdate sets a hook for the model that will
	// be called before the model is updated into the database.
	HookPreUpdate func(m *User)

	// HookPostUpdate sets a hook for the model that will
	// be called after the model is updated into the database.
	HookPostUpdate func(m *User)

	// HookPreDelete sets a hook for the model that will
	// be called before the model is deleted into the database.
	HookPreDelete func(m *User)

	// HookPostDelete sets a hook for the model that will
	// be called after the model is deleted into the database.
	HookPostDelete func(m *User)
}
type userManager struct {
	db          *sql.DB
	storeConfig StoreConfig
	config      UserConfig
}

func newUserManager(db *sql.DB, storeConfig StoreConfig, config UserConfig) *userManager {
	return &userManager{
		config:      config,
		db:          db,
		storeConfig: storeConfig,
	}
}
func (mgr *userManager) Filter(filter ...userFilterArg) *userQueryset {
	v := newUserQueryset(mgr)
	v.Filter(filter...)
	return v
}
func (mgr *userManager) Exclude(exclude ...userFilterArg) *userQueryset {
	v := newUserQueryset(mgr)
	v.Exclude(exclude...)
	return v
}
func (mgr *userManager) Delete(m *User) error {
	// Call hook if provided
	if mgr.config.HookPreDelete != nil {
		mgr.config.HookPreDelete(m)
	}

	// Call delete on queryset with PK as the filter
	err := mgr.Filter(userFilterArg{filter: &sq.Eq{"id": m.ID}}).Delete()
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostDelete != nil {
		mgr.config.HookPostDelete(m)
	}

	return nil
}
func (mgr *userManager) DeleteP(m *User) {
	err := mgr.Delete(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *userManager) Insert(set ...userSetterArg) (*User, error) {
	m := mgr.newModel(set...)
	err := mgr.insertInstance(m)
	if err != nil {
		return nil, err
	}
	return m, err
}
func (mgr *userManager) InsertP(set ...userSetterArg) *User {
	v, err := mgr.Insert(set...)
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *userManager) Validate(m *User) error {
	if m.ID == "" {
		return errors.New("User.ID cannot be blank")
	}
	if m.Email == "" {
		return errors.New("User.Email cannot be blank")
	}
	if m.Name == "" {
		return errors.New("User.Name cannot be blank")
	}
	if m.PasswordHash == "" {
		return errors.New("User.PasswordHash cannot be blank")
	}
	return nil
}
func (mgr *userManager) ValidateP(m *User) {
	err := mgr.Validate(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *userManager) insertInstance(m *User) error {
	// Call hook if provided
	if mgr.config.HookPreInsert != nil {
		mgr.config.HookPreInsert(m)
	}

	err := mgr.Validate(m)
	if err != nil {
		return err
	}

	query := sq.Insert("users")
	query = query.Columns(
		"id",
		"created_at",
		"email",
		"name",
		"password_hash")

	query = query.Values(
		m.ID,
		m.CreatedAt,
		m.Email,
		m.Name,
		m.PasswordHash)

	query = query.Suffix("RETURNING \"id\"")
	q, args := mgr.toSQL(query)
	result := mgr.db.QueryRow(q, args...)

	err = result.Scan(&m.ID)
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostInsert != nil {
		mgr.config.HookPostInsert(m)
	}

	return nil
}
func (mgr *userManager) Update(m *User) error {
	// Call hook if provided
	if mgr.config.HookPreUpdate != nil {
		mgr.config.HookPreUpdate(m)
	}

	// Call update on queryset with PK as the filter
	err := mgr.Filter(userFilterArg{filter: &sq.Eq{"id": m.ID}}).Update(userSetterArg{
		field: "id",
		value: m.ID,
	}, userSetterArg{
		field: "created_at",
		value: m.CreatedAt,
	}, userSetterArg{
		field: "email",
		value: m.Email,
	}, userSetterArg{
		field: "name",
		value: m.Name,
	}, userSetterArg{
		field: "password_hash",
		value: m.PasswordHash,
	})
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostUpdate != nil {
		mgr.config.HookPostUpdate(m)
	}

	return nil
}
func (mgr *userManager) UpdateP(m *User) {
	err := mgr.Update(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *userManager) All() ([]User, error) {
	return mgr.Filter().All()
}
func (mgr *userManager) AllP() []User {
	v, err := mgr.All()
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *userManager) None() ([]User, error) {
	return make([]User, 0), nil
}
func (mgr *userManager) NoneP() []User {
	v, err := mgr.None()
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *userManager) Get(id string) (*User, error) {
	return mgr.Filter(userFilterArg{filter: sq.Eq{"\"users\".\"id\"": id}}).One()
}
func (mgr *userManager) GetP(id string) *User {
	v, err := mgr.Get(id)
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *userManager) newModel(set ...userSetterArg) *User {
	m := NewUser()

	// Apply setters to default struct
	for _, s := range set {
		switch s.field {
		case "id":
			m.ID = s.value.(string)
		case "created_at":
			m.CreatedAt = s.value.(time.Time)
		case "email":
			m.Email = s.value.(string)
		case "name":
			m.Name = s.value.(string)
		case "password_hash":
			m.PasswordHash = s.value.(string)
		default:
			panic("invalid field for setter: " + s.field)
		}
	}

	return m
}
func (mgr *userManager) toSQL(q sq.Sqlizer) (string, []interface{}) {
	query, args, err := q.ToSql()
	if err != nil {
		panic(err)
	}

	query, err = sq.Dollar.ReplacePlaceholders(query)
	if err != nil {
		panic(err)
	}

	return query, args
}

type userQueryset struct {
	mgr     *userManager
	filter  []userFilterArg
	orderBy []userOrderByArg
	limit   uint64
	offset  uint64
}

func newUserQueryset(mgr *userManager) *userQueryset {
	return &userQueryset{
		filter:  make([]userFilterArg, 0),
		limit:   0,
		mgr:     mgr,
		offset:  0,
		orderBy: make([]userOrderByArg, 0),
	}
}
func (qs *userQueryset) Filter(filter ...userFilterArg) *userQueryset {
	qs.filter = append(qs.filter, filter...)
	return qs
}
func (qs *userQueryset) Exclude(exclude ...userFilterArg) *userQueryset {
	q := sq.And{}
	j := make([]string, 0)
	for _, e := range exclude {
		q = append(q, e.filter)
		j = append(j, e.joins...)
	}

	qs.filter = append(qs.filter, userFilterArg{
		filter: sq.ConcatExpr("NOT", q),
		joins:  j,
	})

	return qs
}
func (qs *userQueryset) Sort(orderBy ...userOrderByArg) *userQueryset {
	qs.orderBy = append(qs.orderBy, orderBy...)
	return qs
}
func (qs *userQueryset) Limit(limit uint64) *userQueryset {
	qs.limit = limit
	return qs
}
func (qs *userQueryset) Offset(offset uint64) *userQueryset {
	qs.offset = offset
	return qs
}
func (qs *userQueryset) Update(set ...userSetterArg) error {
	query := sq.Update("users")

	// Apply setters to query
	for _, s := range set {
		query = query.Set(s.field, s.value)
	}

	// Apply filters to query
	for _, f := range qs.filter {
		query = query.Where(f.filter)
	}

	q, args := qs.toSQL(query)
	_, err := qs.mgr.db.Exec(q, args...)
	return err
}
func (qs *userQueryset) UpdateP(set ...userSetterArg) {
	err := qs.Update(set...)
	if err != nil {
		panic(err)
	}
}
func (qs *userQueryset) All() ([]User, error) {
	query := qs.starSelect()
	q, args := qs.toSQL(query)

	rows, err := qs.mgr.db.Query(q, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := make([]User, 0)

	for rows.Next() {
		var m User
		err = qs.scan(rows, &m)
		if err != nil {
			return nil, err
		}
		items = append(items, m)
	}

	return items, err
}
func (qs *userQueryset) AllP() []User {
	v, err := qs.All()
	if err != nil {
		panic(err)
	}
	return v
}
func (qs *userQueryset) One() (*User, error) {
	items, err := qs.All()

	// Ensure we have a result
	if len(items) == 0 {
		return nil, sql.ErrNoRows
	}

	return &items[0], err
}
func (qs *userQueryset) OneP() *User {
	v, err := qs.One()
	if err != nil {
		panic(err)
	}
	return v
}
func (qs *userQueryset) Delete() error {
	query := sq.Delete("users")

	for _, w := range qs.filter {
		query = query.Where(w.filter)
	}

	q, args := qs.toSQL(query)
	_, err := qs.mgr.db.Exec(q, args...)
	return err
}
func (qs *userQueryset) DeleteP() {
	err := qs.Delete()
	if err != nil {
		panic(err)
	}
}
func (qs *userQueryset) scan(r *sql.Rows, m *User) error {
	return r.Scan(
		&m.ID,
		&m.CreatedAt,
		&m.Email,
		&m.Name,
		&m.PasswordHash)
}
func (qs *userQueryset) starSelect() sq.SelectBuilder {
	query := sq.Select(
		"\"users\".\"id\"",
		"\"users\".\"created_at\"",
		"\"users\".\"email\"",
		"\"users\".\"name\"",
		"\"users\".\"password_hash\"").From("users")

	joinCheck := make(map[string]bool)

	// Assign filters and join if necessary
	for _, w := range qs.filter {
		query = query.Where(w.filter)
		for _, j := range w.joins {
			if _, ok := joinCheck[j]; ok {
				continue
			}
			joinCheck[j] = true
			query = query.Join(j)
		}
	}

	// Apply limit if set
	if qs.limit > 0 {
		query = query.Limit(qs.limit)
	}

	// Apply offset if set
	if qs.offset > 0 {
		query = query.Offset(qs.offset)
	}

	// Apply default order if none specified
	if len(qs.orderBy) == 0 {
		// TODO: Add default order-by
	}

	// Apply user-specified order
	for _, s := range qs.orderBy {
		query = query.OrderBy(s.field + " " + s.order)
	}

	return query
}
func (qs *userQueryset) toSQL(q sq.Sqlizer) (string, []interface{}) {
	return qs.mgr.toSQL(q)
}

type userFilterArg struct {
	filter sq.Sqlizer
	joins  []string
}
type userOrderByArg struct {
	field string
	order string
	join  string
}
type userSetterArg struct {
	field string
	value interface{}
}
type userSetters struct{}

// ID sets the "id" field to the provided value.
func (userSetters) ID(v string) userSetterArg {
	return userSetterArg{
		field: "id",
		value: v,
	}
}

// CreatedAt sets the "created_at" field to the provided value.
func (userSetters) CreatedAt(v time.Time) userSetterArg {
	return userSetterArg{
		field: "created_at",
		value: v,
	}
}

// Email sets the "email" field to the provided value.
func (userSetters) Email(v string) userSetterArg {
	return userSetterArg{
		field: "email",
		value: v,
	}
}

// Name sets the "name" field to the provided value.
func (userSetters) Name(v string) userSetterArg {
	return userSetterArg{
		field: "name",
		value: v,
	}
}

// PasswordHash sets the "password_hash" field to the provided value.
func (userSetters) PasswordHash(v string) userSetterArg {
	return userSetterArg{
		field: "password_hash",
		value: v,
	}
}

type userOrders struct {
	ID           userIDOrderByArg
	CreatedAt    userCreatedAtOrderByArg
	Email        userEmailOrderByArg
	Name         userNameOrderByArg
	PasswordHash userPasswordHashOrderByArg
}

type userIDOrderByArg struct {
	// Asc orders results in ascending direction
	Asc userOrderByArg

	// Desc orders results in descending direction
	Desc userOrderByArg
}

type userCreatedAtOrderByArg struct {
	// Asc orders results in ascending direction
	Asc userOrderByArg

	// Desc orders results in descending direction
	Desc userOrderByArg
}

type userEmailOrderByArg struct {
	// Asc orders results in ascending direction
	Asc userOrderByArg

	// Desc orders results in descending direction
	Desc userOrderByArg
}

type userNameOrderByArg struct {
	// Asc orders results in ascending direction
	Asc userOrderByArg

	// Desc orders results in descending direction
	Desc userOrderByArg
}

type userPasswordHashOrderByArg struct {
	// Asc orders results in ascending direction
	Asc userOrderByArg

	// Desc orders results in descending direction
	Desc userOrderByArg
}

func newUserOrders() userOrders {
	return userOrders{
		CreatedAt: userCreatedAtOrderByArg{
			Asc: userOrderByArg{
				field: "\"users\".\"created_at\"",
				join:  "",
				order: "ASC",
			},
			Desc: userOrderByArg{
				field: "\"users\".\"created_at\"",
				join:  "",
				order: "DESC",
			},
		},
		Email: userEmailOrderByArg{
			Asc: userOrderByArg{
				field: "\"users\".\"email\"",
				join:  "",
				order: "ASC",
			},
			Desc: userOrderByArg{
				field: "\"users\".\"email\"",
				join:  "",
				order: "DESC",
			},
		},
		ID: userIDOrderByArg{
			Asc: userOrderByArg{
				field: "\"users\".\"id\"",
				join:  "",
				order: "ASC",
			},
			Desc: userOrderByArg{
				field: "\"users\".\"id\"",
				join:  "",
				order: "DESC",
			},
		},
		Name: userNameOrderByArg{
			Asc: userOrderByArg{
				field: "\"users\".\"name\"",
				join:  "",
				order: "ASC",
			},
			Desc: userOrderByArg{
				field: "\"users\".\"name\"",
				join:  "",
				order: "DESC",
			},
		},
		PasswordHash: userPasswordHashOrderByArg{
			Asc: userOrderByArg{
				field: "\"users\".\"password_hash\"",
				join:  "",
				order: "ASC",
			},
			Desc: userOrderByArg{
				field: "\"users\".\"password_hash\"",
				join:  "",
				order: "DESC",
			},
		},
	}
}

type userIDFilter struct{}

func (userIDFilter) ILike(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" LIKE ?", v)}
}
func (userIDFilter) IContains(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" ILIKE '%' || ? || '%'", v)}
}
func (userIDFilter) IRegex(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" ~* ?", v)}
}
func (userIDFilter) Regex(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" ~ ?", v)}
}
func (userIDFilter) Gt(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" > ?", v)}
}
func (userIDFilter) Gte(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" >= ?", v)}
}
func (userIDFilter) Lt(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" < ?", v)}
}
func (userIDFilter) HasPrefix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" LIKE ? || '%'", v)}
}
func (userIDFilter) Eq(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" = ?", v)}
}
func (userIDFilter) NotEq(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" != ?", v)}
}
func (userIDFilter) Contains(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" LIKE '%' || ? || '%'", v)}
}
func (userIDFilter) Lte(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" <= ?", v)}
}
func (userIDFilter) HasSuffix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" LIKE '%' || ?", v)}
}
func (userIDFilter) IHasPrefix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" ILIKE ? || '%'", v)}
}
func (userIDFilter) IHasSuffix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"id\" ILIKE '%' || ?", v)}
}

type userCreatedAtFilter struct{}

func (userCreatedAtFilter) After(v time.Time) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"created_at\" > ?", v)}
}
func (userCreatedAtFilter) Eq(v time.Time) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"created_at\" = ?", v)}
}
func (userCreatedAtFilter) NotEq(v time.Time) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"created_at\" != ?", v)}
}
func (userCreatedAtFilter) Before(v time.Time) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"created_at\" < ?", v)}
}

type userEmailFilter struct{}

func (userEmailFilter) Lt(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" < ?", v)}
}
func (userEmailFilter) NotEq(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" != ?", v)}
}
func (userEmailFilter) Regex(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" ~ ?", v)}
}
func (userEmailFilter) Contains(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" LIKE '%' || ? || '%'", v)}
}
func (userEmailFilter) IRegex(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" ~* ?", v)}
}
func (userEmailFilter) Gt(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" > ?", v)}
}
func (userEmailFilter) IHasPrefix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" ILIKE ? || '%'", v)}
}
func (userEmailFilter) IContains(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" ILIKE '%' || ? || '%'", v)}
}
func (userEmailFilter) ILike(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" LIKE ?", v)}
}
func (userEmailFilter) Gte(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" >= ?", v)}
}
func (userEmailFilter) Lte(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" <= ?", v)}
}
func (userEmailFilter) HasPrefix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" LIKE ? || '%'", v)}
}
func (userEmailFilter) HasSuffix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" LIKE '%' || ?", v)}
}
func (userEmailFilter) IHasSuffix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" ILIKE '%' || ?", v)}
}
func (userEmailFilter) Eq(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"email\" = ?", v)}
}

type userNameFilter struct{}

func (userNameFilter) Regex(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" ~ ?", v)}
}
func (userNameFilter) IRegex(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" ~* ?", v)}
}
func (userNameFilter) HasSuffix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" LIKE '%' || ?", v)}
}
func (userNameFilter) IHasSuffix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" ILIKE '%' || ?", v)}
}
func (userNameFilter) ILike(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" LIKE ?", v)}
}
func (userNameFilter) NotEq(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" != ?", v)}
}
func (userNameFilter) Contains(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" LIKE '%' || ? || '%'", v)}
}
func (userNameFilter) Gt(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" > ?", v)}
}
func (userNameFilter) Lt(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" < ?", v)}
}
func (userNameFilter) IHasPrefix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" ILIKE ? || '%'", v)}
}
func (userNameFilter) IContains(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" ILIKE '%' || ? || '%'", v)}
}
func (userNameFilter) HasPrefix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" LIKE ? || '%'", v)}
}
func (userNameFilter) Eq(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" = ?", v)}
}
func (userNameFilter) Gte(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" >= ?", v)}
}
func (userNameFilter) Lte(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"name\" <= ?", v)}
}

type userPasswordHashFilter struct{}

func (userPasswordHashFilter) ILike(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" LIKE ?", v)}
}
func (userPasswordHashFilter) Gt(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" > ?", v)}
}
func (userPasswordHashFilter) IHasSuffix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" ILIKE '%' || ?", v)}
}
func (userPasswordHashFilter) NotEq(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" != ?", v)}
}
func (userPasswordHashFilter) Contains(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" LIKE '%' || ? || '%'", v)}
}
func (userPasswordHashFilter) IContains(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" ILIKE '%' || ? || '%'", v)}
}
func (userPasswordHashFilter) IRegex(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" ~* ?", v)}
}
func (userPasswordHashFilter) Lte(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" <= ?", v)}
}
func (userPasswordHashFilter) Regex(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" ~ ?", v)}
}
func (userPasswordHashFilter) Lt(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" < ?", v)}
}
func (userPasswordHashFilter) HasSuffix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" LIKE '%' || ?", v)}
}
func (userPasswordHashFilter) IHasPrefix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" ILIKE ? || '%'", v)}
}
func (userPasswordHashFilter) Eq(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" = ?", v)}
}
func (userPasswordHashFilter) Gte(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" >= ?", v)}
}
func (userPasswordHashFilter) HasPrefix(v string) (filter userFilterArg) {
	return userFilterArg{filter: sq.Expr("\"users\".\"password_hash\" LIKE ? || '%'", v)}
}

type userFilters struct {
	ID           userIDFilter
	CreatedAt    userCreatedAtFilter
	Email        userEmailFilter
	Name         userNameFilter
	PasswordHash userPasswordHashFilter
}

// And combines multiple filters into one
func (userFilters) And(filter ...userFilterArg) userFilterArg {
	q := sq.And{}
	j := make([]string, 0)

	for _, f := range filter {
		q = append(q, f.filter)
		j = append(j, f.joins...)
	}

	return userFilterArg{
		filter: q,
		joins:  j,
	}
}

// Or combines multiple filters into one
func (userFilters) Or(filter ...userFilterArg) userFilterArg {
	q := sq.Or{}
	j := make([]string, 0)

	for _, f := range filter {
		q = append(q, f.filter)
		j = append(j, f.joins...)
	}

	return userFilterArg{
		filter: q,
		joins:  j,
	}
}

// NewsletterSend represents a row in the "newsletter_sends" table
type NewsletterSend struct {
	ID          string    `json:"id"`          // id VARCHAR(25) PRIMARY KEY
	CreatedAt   time.Time `json:"createdAt"`   // created_at TIMESTAMP WITH TIME ZONE NOT NULL
	Key         string    `json:"key"`         // key TEXT NOT NULL UNIQUE
	Recipients  int64     `json:"recipients"`  // recipients INTEGER NOT NULL
	Description string    `json:"description"` // description TEXT NOT NULL
}

// NewNewsletterSend returns a new instance of NewsletterSend with default values
func NewNewsletterSend() *NewsletterSend {
	return &NewsletterSend{
		CreatedAt:   time.Time{},
		Description: "",
		ID:          "",
		Key:         "",
		Recipients:  int64(0),
	}
}

// PrintJSON prints out a JSON string of the model for debugging
func (model *NewsletterSend) PrintJSON() {
	b, err := json.MarshalIndent(model, "// ", "  ")
	if err != nil {
		panic(err)
	}

	fmt.Printf("\n// var %s %T = %s\n\n", "newsletterSend", model, b)
}

type NewsletterSendConfig struct {
	// HookPreInsert sets a hook for the model that will
	// be called before the model is inserted into the database.
	HookPreInsert func(m *NewsletterSend)

	// HookPostInsert sets a hook for the model that will
	// be called after the model is inserted into the database.
	HookPostInsert func(m *NewsletterSend)

	// HookPreUpdate sets a hook for the model that will
	// be called before the model is updated into the database.
	HookPreUpdate func(m *NewsletterSend)

	// HookPostUpdate sets a hook for the model that will
	// be called after the model is updated into the database.
	HookPostUpdate func(m *NewsletterSend)

	// HookPreDelete sets a hook for the model that will
	// be called before the model is deleted into the database.
	HookPreDelete func(m *NewsletterSend)

	// HookPostDelete sets a hook for the model that will
	// be called after the model is deleted into the database.
	HookPostDelete func(m *NewsletterSend)
}
type newsletterSendManager struct {
	db          *sql.DB
	storeConfig StoreConfig
	config      NewsletterSendConfig
}

func newNewsletterSendManager(db *sql.DB, storeConfig StoreConfig, config NewsletterSendConfig) *newsletterSendManager {
	return &newsletterSendManager{
		config:      config,
		db:          db,
		storeConfig: storeConfig,
	}
}
func (mgr *newsletterSendManager) Filter(filter ...newsletterSendFilterArg) *newsletterSendQueryset {
	v := newNewsletterSendQueryset(mgr)
	v.Filter(filter...)
	return v
}
func (mgr *newsletterSendManager) Exclude(exclude ...newsletterSendFilterArg) *newsletterSendQueryset {
	v := newNewsletterSendQueryset(mgr)
	v.Exclude(exclude...)
	return v
}
func (mgr *newsletterSendManager) Delete(m *NewsletterSend) error {
	// Call hook if provided
	if mgr.config.HookPreDelete != nil {
		mgr.config.HookPreDelete(m)
	}

	// Call delete on queryset with PK as the filter
	err := mgr.Filter(newsletterSendFilterArg{filter: &sq.Eq{"id": m.ID}}).Delete()
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostDelete != nil {
		mgr.config.HookPostDelete(m)
	}

	return nil
}
func (mgr *newsletterSendManager) DeleteP(m *NewsletterSend) {
	err := mgr.Delete(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *newsletterSendManager) Insert(set ...newsletterSendSetterArg) (*NewsletterSend, error) {
	m := mgr.newModel(set...)
	err := mgr.insertInstance(m)
	if err != nil {
		return nil, err
	}
	return m, err
}
func (mgr *newsletterSendManager) InsertP(set ...newsletterSendSetterArg) *NewsletterSend {
	v, err := mgr.Insert(set...)
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *newsletterSendManager) Validate(m *NewsletterSend) error {
	if m.ID == "" {
		return errors.New("NewsletterSend.ID cannot be blank")
	}
	if m.Key == "" {
		return errors.New("NewsletterSend.Key cannot be blank")
	}
	if m.Description == "" {
		return errors.New("NewsletterSend.Description cannot be blank")
	}
	return nil
}
func (mgr *newsletterSendManager) ValidateP(m *NewsletterSend) {
	err := mgr.Validate(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *newsletterSendManager) insertInstance(m *NewsletterSend) error {
	// Call hook if provided
	if mgr.config.HookPreInsert != nil {
		mgr.config.HookPreInsert(m)
	}

	err := mgr.Validate(m)
	if err != nil {
		return err
	}

	query := sq.Insert("newsletter_sends")
	query = query.Columns(
		"id",
		"created_at",
		"key",
		"recipients",
		"description")

	query = query.Values(
		m.ID,
		m.CreatedAt,
		m.Key,
		m.Recipients,
		m.Description)

	query = query.Suffix("RETURNING \"id\"")
	q, args := mgr.toSQL(query)
	result := mgr.db.QueryRow(q, args...)

	err = result.Scan(&m.ID)
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostInsert != nil {
		mgr.config.HookPostInsert(m)
	}

	return nil
}
func (mgr *newsletterSendManager) Update(m *NewsletterSend) error {
	// Call hook if provided
	if mgr.config.HookPreUpdate != nil {
		mgr.config.HookPreUpdate(m)
	}

	// Call update on queryset with PK as the filter
	err := mgr.Filter(newsletterSendFilterArg{filter: &sq.Eq{"id": m.ID}}).Update(newsletterSendSetterArg{
		field: "id",
		value: m.ID,
	}, newsletterSendSetterArg{
		field: "created_at",
		value: m.CreatedAt,
	}, newsletterSendSetterArg{
		field: "key",
		value: m.Key,
	}, newsletterSendSetterArg{
		field: "recipients",
		value: m.Recipients,
	}, newsletterSendSetterArg{
		field: "description",
		value: m.Description,
	})
	if err != nil {
		return err
	}

	// Call hook if provided
	if mgr.config.HookPostUpdate != nil {
		mgr.config.HookPostUpdate(m)
	}

	return nil
}
func (mgr *newsletterSendManager) UpdateP(m *NewsletterSend) {
	err := mgr.Update(m)
	if err != nil {
		panic(err)
	}
}
func (mgr *newsletterSendManager) All() ([]NewsletterSend, error) {
	return mgr.Filter().All()
}
func (mgr *newsletterSendManager) AllP() []NewsletterSend {
	v, err := mgr.All()
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *newsletterSendManager) None() ([]NewsletterSend, error) {
	return make([]NewsletterSend, 0), nil
}
func (mgr *newsletterSendManager) NoneP() []NewsletterSend {
	v, err := mgr.None()
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *newsletterSendManager) Get(id string) (*NewsletterSend, error) {
	return mgr.Filter(newsletterSendFilterArg{filter: sq.Eq{"\"newsletter_sends\".\"id\"": id}}).One()
}
func (mgr *newsletterSendManager) GetP(id string) *NewsletterSend {
	v, err := mgr.Get(id)
	if err != nil {
		panic(err)
	}
	return v
}
func (mgr *newsletterSendManager) newModel(set ...newsletterSendSetterArg) *NewsletterSend {
	m := NewNewsletterSend()

	// Apply setters to default struct
	for _, s := range set {
		switch s.field {
		case "id":
			m.ID = s.value.(string)
		case "created_at":
			m.CreatedAt = s.value.(time.Time)
		case "key":
			m.Key = s.value.(string)
		case "recipients":
			m.Recipients = s.value.(int64)
		case "description":
			m.Description = s.value.(string)
		default:
			panic("invalid field for setter: " + s.field)
		}
	}

	return m
}
func (mgr *newsletterSendManager) toSQL(q sq.Sqlizer) (string, []interface{}) {
	query, args, err := q.ToSql()
	if err != nil {
		panic(err)
	}

	query, err = sq.Dollar.ReplacePlaceholders(query)
	if err != nil {
		panic(err)
	}

	return query, args
}

type newsletterSendQueryset struct {
	mgr     *newsletterSendManager
	filter  []newsletterSendFilterArg
	orderBy []newsletterSendOrderByArg
	limit   uint64
	offset  uint64
}

func newNewsletterSendQueryset(mgr *newsletterSendManager) *newsletterSendQueryset {
	return &newsletterSendQueryset{
		filter:  make([]newsletterSendFilterArg, 0),
		limit:   0,
		mgr:     mgr,
		offset:  0,
		orderBy: make([]newsletterSendOrderByArg, 0),
	}
}
func (qs *newsletterSendQueryset) Filter(filter ...newsletterSendFilterArg) *newsletterSendQueryset {
	qs.filter = append(qs.filter, filter...)
	return qs
}
func (qs *newsletterSendQueryset) Exclude(exclude ...newsletterSendFilterArg) *newsletterSendQueryset {
	q := sq.And{}
	j := make([]string, 0)
	for _, e := range exclude {
		q = append(q, e.filter)
		j = append(j, e.joins...)
	}

	qs.filter = append(qs.filter, newsletterSendFilterArg{
		filter: sq.ConcatExpr("NOT", q),
		joins:  j,
	})

	return qs
}
func (qs *newsletterSendQueryset) Sort(orderBy ...newsletterSendOrderByArg) *newsletterSendQueryset {
	qs.orderBy = append(qs.orderBy, orderBy...)
	return qs
}
func (qs *newsletterSendQueryset) Limit(limit uint64) *newsletterSendQueryset {
	qs.limit = limit
	return qs
}
func (qs *newsletterSendQueryset) Offset(offset uint64) *newsletterSendQueryset {
	qs.offset = offset
	return qs
}
func (qs *newsletterSendQueryset) Update(set ...newsletterSendSetterArg) error {
	query := sq.Update("newsletter_sends")

	// Apply setters to query
	for _, s := range set {
		query = query.Set(s.field, s.value)
	}

	// Apply filters to query
	for _, f := range qs.filter {
		query = query.Where(f.filter)
	}

	q, args := qs.toSQL(query)
	_, err := qs.mgr.db.Exec(q, args...)
	return err
}
func (qs *newsletterSendQueryset) UpdateP(set ...newsletterSendSetterArg) {
	err := qs.Update(set...)
	if err != nil {
		panic(err)
	}
}
func (qs *newsletterSendQueryset) All() ([]NewsletterSend, error) {
	query := qs.starSelect()
	q, args := qs.toSQL(query)

	rows, err := qs.mgr.db.Query(q, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := make([]NewsletterSend, 0)

	for rows.Next() {
		var m NewsletterSend
		err = qs.scan(rows, &m)
		if err != nil {
			return nil, err
		}
		items = append(items, m)
	}

	return items, err
}
func (qs *newsletterSendQueryset) AllP() []NewsletterSend {
	v, err := qs.All()
	if err != nil {
		panic(err)
	}
	return v
}
func (qs *newsletterSendQueryset) One() (*NewsletterSend, error) {
	items, err := qs.All()

	// Ensure we have a result
	if len(items) == 0 {
		return nil, sql.ErrNoRows
	}

	return &items[0], err
}
func (qs *newsletterSendQueryset) OneP() *NewsletterSend {
	v, err := qs.One()
	if err != nil {
		panic(err)
	}
	return v
}
func (qs *newsletterSendQueryset) Delete() error {
	query := sq.Delete("newsletter_sends")

	for _, w := range qs.filter {
		query = query.Where(w.filter)
	}

	q, args := qs.toSQL(query)
	_, err := qs.mgr.db.Exec(q, args...)
	return err
}
func (qs *newsletterSendQueryset) DeleteP() {
	err := qs.Delete()
	if err != nil {
		panic(err)
	}
}
func (qs *newsletterSendQueryset) scan(r *sql.Rows, m *NewsletterSend) error {
	return r.Scan(
		&m.ID,
		&m.CreatedAt,
		&m.Key,
		&m.Recipients,
		&m.Description)
}
func (qs *newsletterSendQueryset) starSelect() sq.SelectBuilder {
	query := sq.Select(
		"\"newsletter_sends\".\"id\"",
		"\"newsletter_sends\".\"created_at\"",
		"\"newsletter_sends\".\"key\"",
		"\"newsletter_sends\".\"recipients\"",
		"\"newsletter_sends\".\"description\"").From("newsletter_sends")

	joinCheck := make(map[string]bool)

	// Assign filters and join if necessary
	for _, w := range qs.filter {
		query = query.Where(w.filter)
		for _, j := range w.joins {
			if _, ok := joinCheck[j]; ok {
				continue
			}
			joinCheck[j] = true
			query = query.Join(j)
		}
	}

	// Apply limit if set
	if qs.limit > 0 {
		query = query.Limit(qs.limit)
	}

	// Apply offset if set
	if qs.offset > 0 {
		query = query.Offset(qs.offset)
	}

	// Apply default order if none specified
	if len(qs.orderBy) == 0 {
		// TODO: Add default order-by
	}

	// Apply user-specified order
	for _, s := range qs.orderBy {
		query = query.OrderBy(s.field + " " + s.order)
	}

	return query
}
func (qs *newsletterSendQueryset) toSQL(q sq.Sqlizer) (string, []interface{}) {
	return qs.mgr.toSQL(q)
}

type newsletterSendFilterArg struct {
	filter sq.Sqlizer
	joins  []string
}
type newsletterSendOrderByArg struct {
	field string
	order string
	join  string
}
type newsletterSendSetterArg struct {
	field string
	value interface{}
}
type newsletterSendSetters struct{}

// ID sets the "id" field to the provided value.
func (newsletterSendSetters) ID(v string) newsletterSendSetterArg {
	return newsletterSendSetterArg{
		field: "id",
		value: v,
	}
}

// CreatedAt sets the "created_at" field to the provided value.
func (newsletterSendSetters) CreatedAt(v time.Time) newsletterSendSetterArg {
	return newsletterSendSetterArg{
		field: "created_at",
		value: v,
	}
}

// Key sets the "key" field to the provided value.
func (newsletterSendSetters) Key(v string) newsletterSendSetterArg {
	return newsletterSendSetterArg{
		field: "key",
		value: v,
	}
}

// Recipients sets the "recipients" field to the provided value.
func (newsletterSendSetters) Recipients(v int64) newsletterSendSetterArg {
	return newsletterSendSetterArg{
		field: "recipients",
		value: v,
	}
}

// Description sets the "description" field to the provided value.
func (newsletterSendSetters) Description(v string) newsletterSendSetterArg {
	return newsletterSendSetterArg{
		field: "description",
		value: v,
	}
}

type newsletterSendOrders struct {
	ID          newsletterSendIDOrderByArg
	CreatedAt   newsletterSendCreatedAtOrderByArg
	Key         newsletterSendKeyOrderByArg
	Recipients  newsletterSendRecipientsOrderByArg
	Description newsletterSendDescriptionOrderByArg
}

type newsletterSendIDOrderByArg struct {
	// Asc orders results in ascending direction
	Asc newsletterSendOrderByArg

	// Desc orders results in descending direction
	Desc newsletterSendOrderByArg
}

type newsletterSendCreatedAtOrderByArg struct {
	// Asc orders results in ascending direction
	Asc newsletterSendOrderByArg

	// Desc orders results in descending direction
	Desc newsletterSendOrderByArg
}

type newsletterSendKeyOrderByArg struct {
	// Asc orders results in ascending direction
	Asc newsletterSendOrderByArg

	// Desc orders results in descending direction
	Desc newsletterSendOrderByArg
}

type newsletterSendRecipientsOrderByArg struct {
	// Asc orders results in ascending direction
	Asc newsletterSendOrderByArg

	// Desc orders results in descending direction
	Desc newsletterSendOrderByArg
}

type newsletterSendDescriptionOrderByArg struct {
	// Asc orders results in ascending direction
	Asc newsletterSendOrderByArg

	// Desc orders results in descending direction
	Desc newsletterSendOrderByArg
}

func newNewsletterSendOrders() newsletterSendOrders {
	return newsletterSendOrders{
		CreatedAt: newsletterSendCreatedAtOrderByArg{
			Asc: newsletterSendOrderByArg{
				field: "\"newsletter_sends\".\"created_at\"",
				join:  "",
				order: "ASC",
			},
			Desc: newsletterSendOrderByArg{
				field: "\"newsletter_sends\".\"created_at\"",
				join:  "",
				order: "DESC",
			},
		},
		Description: newsletterSendDescriptionOrderByArg{
			Asc: newsletterSendOrderByArg{
				field: "\"newsletter_sends\".\"description\"",
				join:  "",
				order: "ASC",
			},
			Desc: newsletterSendOrderByArg{
				field: "\"newsletter_sends\".\"description\"",
				join:  "",
				order: "DESC",
			},
		},
		ID: newsletterSendIDOrderByArg{
			Asc: newsletterSendOrderByArg{
				field: "\"newsletter_sends\".\"id\"",
				join:  "",
				order: "ASC",
			},
			Desc: newsletterSendOrderByArg{
				field: "\"newsletter_sends\".\"id\"",
				join:  "",
				order: "DESC",
			},
		},
		Key: newsletterSendKeyOrderByArg{
			Asc: newsletterSendOrderByArg{
				field: "\"newsletter_sends\".\"key\"",
				join:  "",
				order: "ASC",
			},
			Desc: newsletterSendOrderByArg{
				field: "\"newsletter_sends\".\"key\"",
				join:  "",
				order: "DESC",
			},
		},
		Recipients: newsletterSendRecipientsOrderByArg{
			Asc: newsletterSendOrderByArg{
				field: "\"newsletter_sends\".\"recipients\"",
				join:  "",
				order: "ASC",
			},
			Desc: newsletterSendOrderByArg{
				field: "\"newsletter_sends\".\"recipients\"",
				join:  "",
				order: "DESC",
			},
		},
	}
}

type newsletterSendIDFilter struct{}

func (newsletterSendIDFilter) IContains(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" ILIKE '%' || ? || '%'", v)}
}
func (newsletterSendIDFilter) IHasPrefix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" ILIKE ? || '%'", v)}
}
func (newsletterSendIDFilter) IHasSuffix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" ILIKE '%' || ?", v)}
}
func (newsletterSendIDFilter) Eq(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" = ?", v)}
}
func (newsletterSendIDFilter) Gt(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" > ?", v)}
}
func (newsletterSendIDFilter) Lte(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" <= ?", v)}
}
func (newsletterSendIDFilter) IRegex(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" ~* ?", v)}
}
func (newsletterSendIDFilter) Contains(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" LIKE '%' || ? || '%'", v)}
}
func (newsletterSendIDFilter) Gte(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" >= ?", v)}
}
func (newsletterSendIDFilter) NotEq(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" != ?", v)}
}
func (newsletterSendIDFilter) Regex(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" ~ ?", v)}
}
func (newsletterSendIDFilter) Lt(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" < ?", v)}
}
func (newsletterSendIDFilter) HasPrefix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" LIKE ? || '%'", v)}
}
func (newsletterSendIDFilter) HasSuffix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" LIKE '%' || ?", v)}
}
func (newsletterSendIDFilter) ILike(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"id\" LIKE ?", v)}
}

type newsletterSendCreatedAtFilter struct{}

func (newsletterSendCreatedAtFilter) Eq(v time.Time) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"created_at\" = ?", v)}
}
func (newsletterSendCreatedAtFilter) NotEq(v time.Time) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"created_at\" != ?", v)}
}
func (newsletterSendCreatedAtFilter) Before(v time.Time) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"created_at\" < ?", v)}
}
func (newsletterSendCreatedAtFilter) After(v time.Time) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"created_at\" > ?", v)}
}

type newsletterSendKeyFilter struct{}

func (newsletterSendKeyFilter) Lt(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" < ?", v)}
}
func (newsletterSendKeyFilter) HasSuffix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" LIKE '%' || ?", v)}
}
func (newsletterSendKeyFilter) IRegex(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" ~* ?", v)}
}
func (newsletterSendKeyFilter) IHasSuffix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" ILIKE '%' || ?", v)}
}
func (newsletterSendKeyFilter) ILike(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" LIKE ?", v)}
}
func (newsletterSendKeyFilter) Contains(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" LIKE '%' || ? || '%'", v)}
}
func (newsletterSendKeyFilter) IContains(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" ILIKE '%' || ? || '%'", v)}
}
func (newsletterSendKeyFilter) Gte(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" >= ?", v)}
}
func (newsletterSendKeyFilter) Lte(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" <= ?", v)}
}
func (newsletterSendKeyFilter) IHasPrefix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" ILIKE ? || '%'", v)}
}
func (newsletterSendKeyFilter) Eq(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" = ?", v)}
}
func (newsletterSendKeyFilter) Regex(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" ~ ?", v)}
}
func (newsletterSendKeyFilter) Gt(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" > ?", v)}
}
func (newsletterSendKeyFilter) NotEq(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" != ?", v)}
}
func (newsletterSendKeyFilter) HasPrefix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"key\" LIKE ? || '%'", v)}
}

type newsletterSendRecipientsFilter struct{}

func (newsletterSendRecipientsFilter) Eq(v int64) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"recipients\" = ?", v)}
}
func (newsletterSendRecipientsFilter) NotEq(v int64) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"recipients\" != ?", v)}
}
func (newsletterSendRecipientsFilter) Lt(v int64) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"recipients\" < ?", v)}
}
func (newsletterSendRecipientsFilter) Lte(v int64) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"recipients\" <= ?", v)}
}
func (newsletterSendRecipientsFilter) Gt(v int64) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"recipients\" > ?", v)}
}
func (newsletterSendRecipientsFilter) Gte(v int64) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"recipients\" >= ?", v)}
}

type newsletterSendDescriptionFilter struct{}

func (newsletterSendDescriptionFilter) Regex(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" ~ ?", v)}
}
func (newsletterSendDescriptionFilter) IRegex(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" ~* ?", v)}
}
func (newsletterSendDescriptionFilter) Gte(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" >= ?", v)}
}
func (newsletterSendDescriptionFilter) Lt(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" < ?", v)}
}
func (newsletterSendDescriptionFilter) HasPrefix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" LIKE ? || '%'", v)}
}
func (newsletterSendDescriptionFilter) Gt(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" > ?", v)}
}
func (newsletterSendDescriptionFilter) Lte(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" <= ?", v)}
}
func (newsletterSendDescriptionFilter) HasSuffix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" LIKE '%' || ?", v)}
}
func (newsletterSendDescriptionFilter) IHasPrefix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" ILIKE ? || '%'", v)}
}
func (newsletterSendDescriptionFilter) IContains(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" ILIKE '%' || ? || '%'", v)}
}
func (newsletterSendDescriptionFilter) Eq(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" = ?", v)}
}
func (newsletterSendDescriptionFilter) ILike(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" LIKE ?", v)}
}
func (newsletterSendDescriptionFilter) NotEq(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" != ?", v)}
}
func (newsletterSendDescriptionFilter) Contains(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" LIKE '%' || ? || '%'", v)}
}
func (newsletterSendDescriptionFilter) IHasSuffix(v string) (filter newsletterSendFilterArg) {
	return newsletterSendFilterArg{filter: sq.Expr("\"newsletter_sends\".\"description\" ILIKE '%' || ?", v)}
}

type newsletterSendFilters struct {
	ID          newsletterSendIDFilter
	CreatedAt   newsletterSendCreatedAtFilter
	Key         newsletterSendKeyFilter
	Recipients  newsletterSendRecipientsFilter
	Description newsletterSendDescriptionFilter
}

// And combines multiple filters into one
func (newsletterSendFilters) And(filter ...newsletterSendFilterArg) newsletterSendFilterArg {
	q := sq.And{}
	j := make([]string, 0)

	for _, f := range filter {
		q = append(q, f.filter)
		j = append(j, f.joins...)
	}

	return newsletterSendFilterArg{
		filter: q,
		joins:  j,
	}
}

// Or combines multiple filters into one
func (newsletterSendFilters) Or(filter ...newsletterSendFilterArg) newsletterSendFilterArg {
	q := sq.Or{}
	j := make([]string, 0)

	for _, f := range filter {
		q = append(q, f.filter)
		j = append(j, f.joins...)
	}

	return newsletterSendFilterArg{
		filter: q,
		joins:  j,
	}
}
