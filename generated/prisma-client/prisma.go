// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4488"
var Secret = ""

func (client *Client) BlogPost(params BlogPostWhereUniqueInput) *BlogPostExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BlogPostWhereUniqueInput!", "BlogPost"},
		"blogPost",
		[]string{"id", "createdAt", "updatedAt", "published", "slug", "title", "date", "content", "renderedContent"})

	return &BlogPostExec{ret}
}

type BlogPostsParams struct {
	Where   *BlogPostWhereInput   `json:"where,omitempty"`
	OrderBy *BlogPostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) BlogPosts(params *BlogPostsParams) *BlogPostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BlogPostWhereInput", "BlogPostOrderByInput", "BlogPost"},
		"blogPosts",
		[]string{"id", "createdAt", "updatedAt", "published", "slug", "title", "date", "content", "renderedContent"})

	return &BlogPostExecArray{ret}
}

type BlogPostsConnectionParams struct {
	Where   *BlogPostWhereInput   `json:"where,omitempty"`
	OrderBy *BlogPostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) BlogPostsConnection(params *BlogPostsConnectionParams) BlogPostConnectionExec {
	panic("not implemented")
}

func (client *Client) Session(params SessionWhereUniqueInput) *SessionExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"SessionWhereUniqueInput!", "Session"},
		"session",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

type SessionsParams struct {
	Where   *SessionWhereInput   `json:"where,omitempty"`
	OrderBy *SessionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Sessions(params *SessionsParams) *SessionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SessionWhereInput", "SessionOrderByInput", "Session"},
		"sessions",
		[]string{"id", "createdAt"})

	return &SessionExecArray{ret}
}

type SessionsConnectionParams struct {
	Where   *SessionWhereInput   `json:"where,omitempty"`
	OrderBy *SessionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) SessionsConnection(params *SessionsConnectionParams) SessionConnectionExec {
	panic("not implemented")
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) UsersConnection(params *UsersConnectionParams) UserConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateBlogPost(params BlogPostCreateInput) *BlogPostExec {
	ret := client.Client.Create(
		params,
		[2]string{"BlogPostCreateInput!", "BlogPost"},
		"createBlogPost",
		[]string{"id", "createdAt", "updatedAt", "published", "slug", "title", "date", "content", "renderedContent"})

	return &BlogPostExec{ret}
}

type BlogPostUpdateParams struct {
	Data  BlogPostUpdateInput      `json:"data"`
	Where BlogPostWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBlogPost(params BlogPostUpdateParams) *BlogPostExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BlogPostUpdateInput!", "BlogPostWhereUniqueInput!", "BlogPost"},
		"updateBlogPost",
		[]string{"id", "createdAt", "updatedAt", "published", "slug", "title", "date", "content", "renderedContent"})

	return &BlogPostExec{ret}
}

type BlogPostUpdateManyParams struct {
	Data  BlogPostUpdateManyMutationInput `json:"data"`
	Where *BlogPostWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBlogPosts(params BlogPostUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BlogPostUpdateManyMutationInput!", "BlogPostWhereInput"},
		"updateManyBlogPosts")
	return &BatchPayloadExec{exec}
}

type BlogPostUpsertParams struct {
	Where  BlogPostWhereUniqueInput `json:"where"`
	Create BlogPostCreateInput      `json:"create"`
	Update BlogPostUpdateInput      `json:"update"`
}

func (client *Client) UpsertBlogPost(params BlogPostUpsertParams) *BlogPostExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BlogPostWhereUniqueInput!", "BlogPostCreateInput!", "BlogPostUpdateInput!", "BlogPost"},
		"upsertBlogPost",
		[]string{"id", "createdAt", "updatedAt", "published", "slug", "title", "date", "content", "renderedContent"})

	return &BlogPostExec{ret}
}

func (client *Client) DeleteBlogPost(params BlogPostWhereUniqueInput) *BlogPostExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BlogPostWhereUniqueInput!", "BlogPost"},
		"deleteBlogPost",
		[]string{"id", "createdAt", "updatedAt", "published", "slug", "title", "date", "content", "renderedContent"})

	return &BlogPostExec{ret}
}

func (client *Client) DeleteManyBlogPosts(params *BlogPostWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BlogPostWhereInput", "deleteManyBlogPosts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateSession(params SessionCreateInput) *SessionExec {
	ret := client.Client.Create(
		params,
		[2]string{"SessionCreateInput!", "Session"},
		"createSession",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

type SessionUpdateParams struct {
	Data  SessionUpdateInput      `json:"data"`
	Where SessionWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateSession(params SessionUpdateParams) *SessionExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"SessionUpdateInput!", "SessionWhereUniqueInput!", "Session"},
		"updateSession",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

type SessionUpsertParams struct {
	Where  SessionWhereUniqueInput `json:"where"`
	Create SessionCreateInput      `json:"create"`
	Update SessionUpdateInput      `json:"update"`
}

func (client *Client) UpsertSession(params SessionUpsertParams) *SessionExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"SessionWhereUniqueInput!", "SessionCreateInput!", "SessionUpdateInput!", "Session"},
		"upsertSession",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

func (client *Client) DeleteSession(params SessionWhereUniqueInput) *SessionExec {
	ret := client.Client.Delete(
		params,
		[2]string{"SessionWhereUniqueInput!", "Session"},
		"deleteSession",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

func (client *Client) DeleteManySessions(params *SessionWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "SessionWhereInput", "deleteManySessions")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type UserType string

const (
	UserTypeAdmin UserType = "ADMIN"
	UserTypeGuest UserType = "GUEST"
)

type BlogPostOrderByInput string

const (
	BlogPostOrderByInputIDAsc               BlogPostOrderByInput = "id_ASC"
	BlogPostOrderByInputIDDesc              BlogPostOrderByInput = "id_DESC"
	BlogPostOrderByInputCreatedAtAsc        BlogPostOrderByInput = "createdAt_ASC"
	BlogPostOrderByInputCreatedAtDesc       BlogPostOrderByInput = "createdAt_DESC"
	BlogPostOrderByInputUpdatedAtAsc        BlogPostOrderByInput = "updatedAt_ASC"
	BlogPostOrderByInputUpdatedAtDesc       BlogPostOrderByInput = "updatedAt_DESC"
	BlogPostOrderByInputPublishedAsc        BlogPostOrderByInput = "published_ASC"
	BlogPostOrderByInputPublishedDesc       BlogPostOrderByInput = "published_DESC"
	BlogPostOrderByInputSlugAsc             BlogPostOrderByInput = "slug_ASC"
	BlogPostOrderByInputSlugDesc            BlogPostOrderByInput = "slug_DESC"
	BlogPostOrderByInputTitleAsc            BlogPostOrderByInput = "title_ASC"
	BlogPostOrderByInputTitleDesc           BlogPostOrderByInput = "title_DESC"
	BlogPostOrderByInputDateAsc             BlogPostOrderByInput = "date_ASC"
	BlogPostOrderByInputDateDesc            BlogPostOrderByInput = "date_DESC"
	BlogPostOrderByInputContentAsc          BlogPostOrderByInput = "content_ASC"
	BlogPostOrderByInputContentDesc         BlogPostOrderByInput = "content_DESC"
	BlogPostOrderByInputRenderedContentAsc  BlogPostOrderByInput = "renderedContent_ASC"
	BlogPostOrderByInputRenderedContentDesc BlogPostOrderByInput = "renderedContent_DESC"
)

type SessionOrderByInput string

const (
	SessionOrderByInputIDAsc         SessionOrderByInput = "id_ASC"
	SessionOrderByInputIDDesc        SessionOrderByInput = "id_DESC"
	SessionOrderByInputCreatedAtAsc  SessionOrderByInput = "createdAt_ASC"
	SessionOrderByInputCreatedAtDesc SessionOrderByInput = "createdAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc            UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc           UserOrderByInput = "id_DESC"
	UserOrderByInputTypeAsc          UserOrderByInput = "type_ASC"
	UserOrderByInputTypeDesc         UserOrderByInput = "type_DESC"
	UserOrderByInputCreatedAtAsc     UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc    UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc     UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc    UserOrderByInput = "updatedAt_DESC"
	UserOrderByInputEmailAsc         UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc        UserOrderByInput = "email_DESC"
	UserOrderByInputNameAsc          UserOrderByInput = "name_ASC"
	UserOrderByInputNameDesc         UserOrderByInput = "name_DESC"
	UserOrderByInputPasswordHashAsc  UserOrderByInput = "passwordHash_ASC"
	UserOrderByInputPasswordHashDesc UserOrderByInput = "passwordHash_DESC"
)

type BlogPostUpdateManyMutationInput struct {
	Published       *bool   `json:"published,omitempty"`
	Slug            *string `json:"slug,omitempty"`
	Title           *string `json:"title,omitempty"`
	Date            *string `json:"date,omitempty"`
	Content         *string `json:"content,omitempty"`
	RenderedContent *string `json:"renderedContent,omitempty"`
}

type BlogPostWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

type SessionWhereInput struct {
	ID              *string             `json:"id,omitempty"`
	IDNot           *string             `json:"id_not,omitempty"`
	IDIn            []string            `json:"id_in,omitempty"`
	IDNotIn         []string            `json:"id_not_in,omitempty"`
	IDLt            *string             `json:"id_lt,omitempty"`
	IDLte           *string             `json:"id_lte,omitempty"`
	IDGt            *string             `json:"id_gt,omitempty"`
	IDGte           *string             `json:"id_gte,omitempty"`
	IDContains      *string             `json:"id_contains,omitempty"`
	IDNotContains   *string             `json:"id_not_contains,omitempty"`
	IDStartsWith    *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string             `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string             `json:"createdAt,omitempty"`
	CreatedAtNot    *string             `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string             `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string             `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string             `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string             `json:"createdAt_gte,omitempty"`
	User            *UserWhereInput     `json:"user,omitempty"`
	And             []SessionWhereInput `json:"AND,omitempty"`
	Or              []SessionWhereInput `json:"OR,omitempty"`
	Not             []SessionWhereInput `json:"NOT,omitempty"`
}

type BlogPostWhereInput struct {
	ID                           *string              `json:"id,omitempty"`
	IDNot                        *string              `json:"id_not,omitempty"`
	IDIn                         []string             `json:"id_in,omitempty"`
	IDNotIn                      []string             `json:"id_not_in,omitempty"`
	IDLt                         *string              `json:"id_lt,omitempty"`
	IDLte                        *string              `json:"id_lte,omitempty"`
	IDGt                         *string              `json:"id_gt,omitempty"`
	IDGte                        *string              `json:"id_gte,omitempty"`
	IDContains                   *string              `json:"id_contains,omitempty"`
	IDNotContains                *string              `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string              `json:"id_not_ends_with,omitempty"`
	CreatedAt                    *string              `json:"createdAt,omitempty"`
	CreatedAtNot                 *string              `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string              `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string              `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string              `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string              `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string              `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string              `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string             `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string             `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string              `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string              `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string              `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string              `json:"updatedAt_gte,omitempty"`
	Published                    *bool                `json:"published,omitempty"`
	PublishedNot                 *bool                `json:"published_not,omitempty"`
	Slug                         *string              `json:"slug,omitempty"`
	SlugNot                      *string              `json:"slug_not,omitempty"`
	SlugIn                       []string             `json:"slug_in,omitempty"`
	SlugNotIn                    []string             `json:"slug_not_in,omitempty"`
	SlugLt                       *string              `json:"slug_lt,omitempty"`
	SlugLte                      *string              `json:"slug_lte,omitempty"`
	SlugGt                       *string              `json:"slug_gt,omitempty"`
	SlugGte                      *string              `json:"slug_gte,omitempty"`
	SlugContains                 *string              `json:"slug_contains,omitempty"`
	SlugNotContains              *string              `json:"slug_not_contains,omitempty"`
	SlugStartsWith               *string              `json:"slug_starts_with,omitempty"`
	SlugNotStartsWith            *string              `json:"slug_not_starts_with,omitempty"`
	SlugEndsWith                 *string              `json:"slug_ends_with,omitempty"`
	SlugNotEndsWith              *string              `json:"slug_not_ends_with,omitempty"`
	Title                        *string              `json:"title,omitempty"`
	TitleNot                     *string              `json:"title_not,omitempty"`
	TitleIn                      []string             `json:"title_in,omitempty"`
	TitleNotIn                   []string             `json:"title_not_in,omitempty"`
	TitleLt                      *string              `json:"title_lt,omitempty"`
	TitleLte                     *string              `json:"title_lte,omitempty"`
	TitleGt                      *string              `json:"title_gt,omitempty"`
	TitleGte                     *string              `json:"title_gte,omitempty"`
	TitleContains                *string              `json:"title_contains,omitempty"`
	TitleNotContains             *string              `json:"title_not_contains,omitempty"`
	TitleStartsWith              *string              `json:"title_starts_with,omitempty"`
	TitleNotStartsWith           *string              `json:"title_not_starts_with,omitempty"`
	TitleEndsWith                *string              `json:"title_ends_with,omitempty"`
	TitleNotEndsWith             *string              `json:"title_not_ends_with,omitempty"`
	Date                         *string              `json:"date,omitempty"`
	DateNot                      *string              `json:"date_not,omitempty"`
	DateIn                       []string             `json:"date_in,omitempty"`
	DateNotIn                    []string             `json:"date_not_in,omitempty"`
	DateLt                       *string              `json:"date_lt,omitempty"`
	DateLte                      *string              `json:"date_lte,omitempty"`
	DateGt                       *string              `json:"date_gt,omitempty"`
	DateGte                      *string              `json:"date_gte,omitempty"`
	Author                       *UserWhereInput      `json:"author,omitempty"`
	Content                      *string              `json:"content,omitempty"`
	ContentNot                   *string              `json:"content_not,omitempty"`
	ContentIn                    []string             `json:"content_in,omitempty"`
	ContentNotIn                 []string             `json:"content_not_in,omitempty"`
	ContentLt                    *string              `json:"content_lt,omitempty"`
	ContentLte                   *string              `json:"content_lte,omitempty"`
	ContentGt                    *string              `json:"content_gt,omitempty"`
	ContentGte                   *string              `json:"content_gte,omitempty"`
	ContentContains              *string              `json:"content_contains,omitempty"`
	ContentNotContains           *string              `json:"content_not_contains,omitempty"`
	ContentStartsWith            *string              `json:"content_starts_with,omitempty"`
	ContentNotStartsWith         *string              `json:"content_not_starts_with,omitempty"`
	ContentEndsWith              *string              `json:"content_ends_with,omitempty"`
	ContentNotEndsWith           *string              `json:"content_not_ends_with,omitempty"`
	RenderedContent              *string              `json:"renderedContent,omitempty"`
	RenderedContentNot           *string              `json:"renderedContent_not,omitempty"`
	RenderedContentIn            []string             `json:"renderedContent_in,omitempty"`
	RenderedContentNotIn         []string             `json:"renderedContent_not_in,omitempty"`
	RenderedContentLt            *string              `json:"renderedContent_lt,omitempty"`
	RenderedContentLte           *string              `json:"renderedContent_lte,omitempty"`
	RenderedContentGt            *string              `json:"renderedContent_gt,omitempty"`
	RenderedContentGte           *string              `json:"renderedContent_gte,omitempty"`
	RenderedContentContains      *string              `json:"renderedContent_contains,omitempty"`
	RenderedContentNotContains   *string              `json:"renderedContent_not_contains,omitempty"`
	RenderedContentStartsWith    *string              `json:"renderedContent_starts_with,omitempty"`
	RenderedContentNotStartsWith *string              `json:"renderedContent_not_starts_with,omitempty"`
	RenderedContentEndsWith      *string              `json:"renderedContent_ends_with,omitempty"`
	RenderedContentNotEndsWith   *string              `json:"renderedContent_not_ends_with,omitempty"`
	And                          []BlogPostWhereInput `json:"AND,omitempty"`
	Or                           []BlogPostWhereInput `json:"OR,omitempty"`
	Not                          []BlogPostWhereInput `json:"NOT,omitempty"`
}

type BlogPostSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *BlogPostWhereInput              `json:"node,omitempty"`
	And                        []BlogPostSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BlogPostSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BlogPostSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Type         *UserType `json:"type,omitempty"`
	Email        *string   `json:"email,omitempty"`
	Name         *string   `json:"name,omitempty"`
	PasswordHash *string   `json:"passwordHash,omitempty"`
}

type UserUpdateOneRequiredInput struct {
	Create  *UserCreateInput       `json:"create,omitempty"`
	Update  *UserUpdateDataInput   `json:"update,omitempty"`
	Upsert  *UserUpsertNestedInput `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput  `json:"connect,omitempty"`
}

type SessionUpdateInput struct {
	User *UserUpdateOneRequiredInput `json:"user,omitempty"`
}

type BlogPostUpdateInput struct {
	Published       *bool                       `json:"published,omitempty"`
	Slug            *string                     `json:"slug,omitempty"`
	Title           *string                     `json:"title,omitempty"`
	Date            *string                     `json:"date,omitempty"`
	Author          *UserUpdateOneRequiredInput `json:"author,omitempty"`
	Content         *string                     `json:"content,omitempty"`
	RenderedContent *string                     `json:"renderedContent,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserCreateInput struct {
	ID           *string   `json:"id,omitempty"`
	Type         *UserType `json:"type,omitempty"`
	Email        string    `json:"email"`
	Name         string    `json:"name"`
	PasswordHash string    `json:"passwordHash"`
}

type SessionWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BlogPostCreateInput struct {
	ID              *string            `json:"id,omitempty"`
	Published       bool               `json:"published"`
	Slug            string             `json:"slug"`
	Title           string             `json:"title"`
	Date            string             `json:"date"`
	Author          UserCreateOneInput `json:"author"`
	Content         string             `json:"content"`
	RenderedContent string             `json:"renderedContent"`
}

type UserCreateOneInput struct {
	Create  *UserCreateInput      `json:"create,omitempty"`
	Connect *UserWhereUniqueInput `json:"connect,omitempty"`
}

type SessionSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *SessionWhereInput              `json:"node,omitempty"`
	And                        []SessionSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []SessionSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []SessionSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

type UserUpdateDataInput struct {
	Type         *UserType `json:"type,omitempty"`
	Email        *string   `json:"email,omitempty"`
	Name         *string   `json:"name,omitempty"`
	PasswordHash *string   `json:"passwordHash,omitempty"`
}

type UserUpsertNestedInput struct {
	Update UserUpdateDataInput `json:"update"`
	Create UserCreateInput     `json:"create"`
}

type SessionCreateInput struct {
	ID   *string            `json:"id,omitempty"`
	User UserCreateOneInput `json:"user"`
}

type UserUpdateInput struct {
	Type         *UserType `json:"type,omitempty"`
	Email        *string   `json:"email,omitempty"`
	Name         *string   `json:"name,omitempty"`
	PasswordHash *string   `json:"passwordHash,omitempty"`
}

type UserWhereInput struct {
	ID                        *string          `json:"id,omitempty"`
	IDNot                     *string          `json:"id_not,omitempty"`
	IDIn                      []string         `json:"id_in,omitempty"`
	IDNotIn                   []string         `json:"id_not_in,omitempty"`
	IDLt                      *string          `json:"id_lt,omitempty"`
	IDLte                     *string          `json:"id_lte,omitempty"`
	IDGt                      *string          `json:"id_gt,omitempty"`
	IDGte                     *string          `json:"id_gte,omitempty"`
	IDContains                *string          `json:"id_contains,omitempty"`
	IDNotContains             *string          `json:"id_not_contains,omitempty"`
	IDStartsWith              *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string          `json:"id_not_ends_with,omitempty"`
	Type                      *UserType        `json:"type,omitempty"`
	TypeNot                   *UserType        `json:"type_not,omitempty"`
	TypeIn                    []UserType       `json:"type_in,omitempty"`
	TypeNotIn                 []UserType       `json:"type_not_in,omitempty"`
	CreatedAt                 *string          `json:"createdAt,omitempty"`
	CreatedAtNot              *string          `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string          `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string          `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string          `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string          `json:"createdAt_gte,omitempty"`
	UpdatedAt                 *string          `json:"updatedAt,omitempty"`
	UpdatedAtNot              *string          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn               []string         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn            []string         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt               *string          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte              *string          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt               *string          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte              *string          `json:"updatedAt_gte,omitempty"`
	Email                     *string          `json:"email,omitempty"`
	EmailNot                  *string          `json:"email_not,omitempty"`
	EmailIn                   []string         `json:"email_in,omitempty"`
	EmailNotIn                []string         `json:"email_not_in,omitempty"`
	EmailLt                   *string          `json:"email_lt,omitempty"`
	EmailLte                  *string          `json:"email_lte,omitempty"`
	EmailGt                   *string          `json:"email_gt,omitempty"`
	EmailGte                  *string          `json:"email_gte,omitempty"`
	EmailContains             *string          `json:"email_contains,omitempty"`
	EmailNotContains          *string          `json:"email_not_contains,omitempty"`
	EmailStartsWith           *string          `json:"email_starts_with,omitempty"`
	EmailNotStartsWith        *string          `json:"email_not_starts_with,omitempty"`
	EmailEndsWith             *string          `json:"email_ends_with,omitempty"`
	EmailNotEndsWith          *string          `json:"email_not_ends_with,omitempty"`
	Name                      *string          `json:"name,omitempty"`
	NameNot                   *string          `json:"name_not,omitempty"`
	NameIn                    []string         `json:"name_in,omitempty"`
	NameNotIn                 []string         `json:"name_not_in,omitempty"`
	NameLt                    *string          `json:"name_lt,omitempty"`
	NameLte                   *string          `json:"name_lte,omitempty"`
	NameGt                    *string          `json:"name_gt,omitempty"`
	NameGte                   *string          `json:"name_gte,omitempty"`
	NameContains              *string          `json:"name_contains,omitempty"`
	NameNotContains           *string          `json:"name_not_contains,omitempty"`
	NameStartsWith            *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith         *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith              *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith           *string          `json:"name_not_ends_with,omitempty"`
	PasswordHash              *string          `json:"passwordHash,omitempty"`
	PasswordHashNot           *string          `json:"passwordHash_not,omitempty"`
	PasswordHashIn            []string         `json:"passwordHash_in,omitempty"`
	PasswordHashNotIn         []string         `json:"passwordHash_not_in,omitempty"`
	PasswordHashLt            *string          `json:"passwordHash_lt,omitempty"`
	PasswordHashLte           *string          `json:"passwordHash_lte,omitempty"`
	PasswordHashGt            *string          `json:"passwordHash_gt,omitempty"`
	PasswordHashGte           *string          `json:"passwordHash_gte,omitempty"`
	PasswordHashContains      *string          `json:"passwordHash_contains,omitempty"`
	PasswordHashNotContains   *string          `json:"passwordHash_not_contains,omitempty"`
	PasswordHashStartsWith    *string          `json:"passwordHash_starts_with,omitempty"`
	PasswordHashNotStartsWith *string          `json:"passwordHash_not_starts_with,omitempty"`
	PasswordHashEndsWith      *string          `json:"passwordHash_ends_with,omitempty"`
	PasswordHashNotEndsWith   *string          `json:"passwordHash_not_ends_with,omitempty"`
	And                       []UserWhereInput `json:"AND,omitempty"`
	Or                        []UserWhereInput `json:"OR,omitempty"`
	Not                       []UserWhereInput `json:"NOT,omitempty"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserEdge struct {
	Cursor string `json:"cursor"`
}

type BlogPostConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BlogPostConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BlogPostConnectionExec) Edges() *BlogPostEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BlogPostEdge"},
		"edges",
		[]string{"cursor"})

	return &BlogPostEdgeExec{ret}
}

func (instance *BlogPostConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBlogPost"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance BlogPostConnectionExec) Exec(ctx context.Context) (*BlogPostConnection, error) {
	var v BlogPostConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlogPostConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlogPostConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BlogPostConnectionExecArray) Exec(ctx context.Context) ([]BlogPostConnection, error) {
	var v []BlogPostConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BlogPostConnection struct {
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserPreviousValues struct {
	ID           string   `json:"id"`
	Type         UserType `json:"type"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
	Email        string   `json:"email"`
	Name         string   `json:"name"`
	PasswordHash string   `json:"passwordHash"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserEdge"},
		"edges",
		[]string{"cursor"})

	return &UserEdgeExec{ret}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	var v UserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserConnection struct {
}

type UserExec struct {
	exec *prisma.Exec
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type User struct {
	ID           string   `json:"id"`
	Type         UserType `json:"type"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
	Email        string   `json:"email"`
	Name         string   `json:"name"`
	PasswordHash string   `json:"passwordHash"`
}

type SessionEdgeExec struct {
	exec *prisma.Exec
}

func (instance *SessionEdgeExec) Node() *SessionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Session"},
		"node",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

func (instance SessionEdgeExec) Exec(ctx context.Context) (*SessionEdge, error) {
	var v SessionEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance SessionEdgeExecArray) Exec(ctx context.Context) ([]SessionEdge, error) {
	var v []SessionEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SessionEdge struct {
	Cursor string `json:"cursor"`
}

type BlogPostExec struct {
	exec *prisma.Exec
}

func (instance *BlogPostExec) Author() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"author",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (instance BlogPostExec) Exec(ctx context.Context) (*BlogPost, error) {
	var v BlogPost
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlogPostExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlogPostExecArray struct {
	exec *prisma.Exec
}

func (instance BlogPostExecArray) Exec(ctx context.Context) ([]BlogPost, error) {
	var v []BlogPost
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BlogPost struct {
	ID              string `json:"id"`
	CreatedAt       string `json:"createdAt"`
	UpdatedAt       string `json:"updatedAt"`
	Published       bool   `json:"published"`
	Slug            string `json:"slug"`
	Title           string `json:"title"`
	Date            string `json:"date"`
	Content         string `json:"content"`
	RenderedContent string `json:"renderedContent"`
}

type SessionConnectionExec struct {
	exec *prisma.Exec
}

func (instance *SessionConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *SessionConnectionExec) Edges() *SessionEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SessionEdge"},
		"edges",
		[]string{"cursor"})

	return &SessionEdgeExec{ret}
}

func (instance *SessionConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateSession"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance SessionConnectionExec) Exec(ctx context.Context) (*SessionConnection, error) {
	var v SessionConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance SessionConnectionExecArray) Exec(ctx context.Context) ([]SessionConnection, error) {
	var v []SessionConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SessionConnection struct {
}

type SessionExec struct {
	exec *prisma.Exec
}

func (instance *SessionExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (instance SessionExec) Exec(ctx context.Context) (*Session, error) {
	var v Session
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionExecArray struct {
	exec *prisma.Exec
}

func (instance SessionExecArray) Exec(ctx context.Context) ([]Session, error) {
	var v []Session
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Session struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
}

type BlogPostPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BlogPostPreviousValuesExec) Exec(ctx context.Context) (*BlogPostPreviousValues, error) {
	var v BlogPostPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlogPostPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlogPostPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BlogPostPreviousValuesExecArray) Exec(ctx context.Context) ([]BlogPostPreviousValues, error) {
	var v []BlogPostPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BlogPostPreviousValues struct {
	ID              string `json:"id"`
	CreatedAt       string `json:"createdAt"`
	UpdatedAt       string `json:"updatedAt"`
	Published       bool   `json:"published"`
	Slug            string `json:"slug"`
	Title           string `json:"title"`
	Date            string `json:"date"`
	Content         string `json:"content"`
	RenderedContent string `json:"renderedContent"`
}

type BlogPostSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BlogPostSubscriptionPayloadExec) Node() *BlogPostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BlogPost"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "published", "slug", "title", "date", "content", "renderedContent"})

	return &BlogPostExec{ret}
}

func (instance *BlogPostSubscriptionPayloadExec) PreviousValues() *BlogPostPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BlogPostPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "published", "slug", "title", "date", "content", "renderedContent"})

	return &BlogPostPreviousValuesExec{ret}
}

func (instance BlogPostSubscriptionPayloadExec) Exec(ctx context.Context) (*BlogPostSubscriptionPayload, error) {
	var v BlogPostSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlogPostSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlogPostSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BlogPostSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BlogPostSubscriptionPayload, error) {
	var v []BlogPostSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BlogPostSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type SessionSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *SessionSubscriptionPayloadExec) Node() *SessionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Session"},
		"node",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

func (instance *SessionSubscriptionPayloadExec) PreviousValues() *SessionPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SessionPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt"})

	return &SessionPreviousValuesExec{ret}
}

func (instance SessionSubscriptionPayloadExec) Exec(ctx context.Context) (*SessionSubscriptionPayload, error) {
	var v SessionSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance SessionSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]SessionSubscriptionPayload, error) {
	var v []SessionSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SessionSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type BlogPostEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BlogPostEdgeExec) Node() *BlogPostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BlogPost"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "published", "slug", "title", "date", "content", "renderedContent"})

	return &BlogPostExec{ret}
}

func (instance BlogPostEdgeExec) Exec(ctx context.Context) (*BlogPostEdge, error) {
	var v BlogPostEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlogPostEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlogPostEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BlogPostEdgeExecArray) Exec(ctx context.Context) ([]BlogPostEdge, error) {
	var v []BlogPostEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type BlogPostEdge struct {
	Cursor string `json:"cursor"`
}

type SessionPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance SessionPreviousValuesExec) Exec(ctx context.Context) (*SessionPreviousValues, error) {
	var v SessionPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance SessionPreviousValuesExecArray) Exec(ctx context.Context) ([]SessionPreviousValues, error) {
	var v []SessionPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type SessionPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}
