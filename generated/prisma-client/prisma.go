// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"os"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = os.Getenv("PRISMA_ENDPOINT")
var Secret = os.Getenv("PRISMA_SECRET")

func (client *Client) BlogPost(params BlogPostWhereUniqueInput) *BlogPostExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BlogPostWhereUniqueInput!", "BlogPost"},
		"blogPost",
		[]string{"id", "createdAt", "updatedAt", "slug", "published", "image", "title", "date", "content", "tags"})

	return &BlogPostExec{ret}
}

type BlogPostsParams struct {
	Where   *BlogPostWhereInput   `json:"where,omitempty"`
	OrderBy *BlogPostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) BlogPosts(params *BlogPostsParams) *BlogPostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BlogPostWhereInput", "BlogPostOrderByInput", "BlogPost"},
		"blogPosts",
		[]string{"id", "createdAt", "updatedAt", "slug", "published", "image", "title", "date", "content", "tags"})

	return &BlogPostExecArray{ret}
}

type BlogPostsConnectionParams struct {
	Where   *BlogPostWhereInput   `json:"where,omitempty"`
	OrderBy *BlogPostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *BlogPostConnection) Nodes() []BlogPost {
	var nodes []BlogPost
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *BlogPostConnection) NodesPtr() []*BlogPost {
	var nodes []*BlogPost
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) BlogPostsConnection(params *BlogPostsConnectionParams) *BlogPostConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BlogPostWhereInput", "BlogPostOrderByInput", "BlogPost"},
		"blogPostsConnection",
		[]string{"edges", "pageInfo"})

	return &BlogPostConnectionExec{ret}
}

func (client *Client) Book(params BookWhereUniqueInput) *BookExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BookWhereUniqueInput!", "Book"},
		"book",
		[]string{"id", "title", "author", "rank", "link"})

	return &BookExec{ret}
}

type BooksParams struct {
	Where   *BookWhereInput   `json:"where,omitempty"`
	OrderBy *BookOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Books(params *BooksParams) *BookExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BookWhereInput", "BookOrderByInput", "Book"},
		"books",
		[]string{"id", "title", "author", "rank", "link"})

	return &BookExecArray{ret}
}

type BooksConnectionParams struct {
	Where   *BookWhereInput   `json:"where,omitempty"`
	OrderBy *BookOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *BookConnection) Nodes() []Book {
	var nodes []Book
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *BookConnection) NodesPtr() []*Book {
	var nodes []*Book
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) BooksConnection(params *BooksConnectionParams) *BookConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BookWhereInput", "BookOrderByInput", "Book"},
		"booksConnection",
		[]string{"edges", "pageInfo"})

	return &BookConnectionExec{ret}
}

func (client *Client) FavoriteThing(params FavoriteThingWhereUniqueInput) *FavoriteThingExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"FavoriteThingWhereUniqueInput!", "FavoriteThing"},
		"favoriteThing",
		[]string{"id", "priority", "name", "link", "description"})

	return &FavoriteThingExec{ret}
}

type FavoriteThingsParams struct {
	Where   *FavoriteThingWhereInput   `json:"where,omitempty"`
	OrderBy *FavoriteThingOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) FavoriteThings(params *FavoriteThingsParams) *FavoriteThingExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FavoriteThingWhereInput", "FavoriteThingOrderByInput", "FavoriteThing"},
		"favoriteThings",
		[]string{"id", "priority", "name", "link", "description"})

	return &FavoriteThingExecArray{ret}
}

type FavoriteThingsConnectionParams struct {
	Where   *FavoriteThingWhereInput   `json:"where,omitempty"`
	OrderBy *FavoriteThingOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *FavoriteThingConnection) Nodes() []FavoriteThing {
	var nodes []FavoriteThing
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *FavoriteThingConnection) NodesPtr() []*FavoriteThing {
	var nodes []*FavoriteThing
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) FavoriteThingsConnection(params *FavoriteThingsConnectionParams) *FavoriteThingConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FavoriteThingWhereInput", "FavoriteThingOrderByInput", "FavoriteThing"},
		"favoriteThingsConnection",
		[]string{"edges", "pageInfo"})

	return &FavoriteThingConnectionExec{ret}
}

func (client *Client) NewsletterSend(params NewsletterSendWhereUniqueInput) *NewsletterSendExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"NewsletterSendWhereUniqueInput!", "NewsletterSend"},
		"newsletterSend",
		[]string{"id", "key", "createdAt", "recipients", "description"})

	return &NewsletterSendExec{ret}
}

type NewsletterSendsParams struct {
	Where   *NewsletterSendWhereInput   `json:"where,omitempty"`
	OrderBy *NewsletterSendOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) NewsletterSends(params *NewsletterSendsParams) *NewsletterSendExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"NewsletterSendWhereInput", "NewsletterSendOrderByInput", "NewsletterSend"},
		"newsletterSends",
		[]string{"id", "key", "createdAt", "recipients", "description"})

	return &NewsletterSendExecArray{ret}
}

type NewsletterSendsConnectionParams struct {
	Where   *NewsletterSendWhereInput   `json:"where,omitempty"`
	OrderBy *NewsletterSendOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *NewsletterSendConnection) Nodes() []NewsletterSend {
	var nodes []NewsletterSend
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *NewsletterSendConnection) NodesPtr() []*NewsletterSend {
	var nodes []*NewsletterSend
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) NewsletterSendsConnection(params *NewsletterSendsConnectionParams) *NewsletterSendConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"NewsletterSendWhereInput", "NewsletterSendOrderByInput", "NewsletterSend"},
		"newsletterSendsConnection",
		[]string{"edges", "pageInfo"})

	return &NewsletterSendConnectionExec{ret}
}

func (client *Client) Project(params ProjectWhereUniqueInput) *ProjectExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ProjectWhereUniqueInput!", "Project"},
		"project",
		[]string{"id", "priority", "name", "link", "icon", "description", "retired", "revenue", "reason"})

	return &ProjectExec{ret}
}

type ProjectsParams struct {
	Where   *ProjectWhereInput   `json:"where,omitempty"`
	OrderBy *ProjectOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Projects(params *ProjectsParams) *ProjectExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProjectWhereInput", "ProjectOrderByInput", "Project"},
		"projects",
		[]string{"id", "priority", "name", "link", "icon", "description", "retired", "revenue", "reason"})

	return &ProjectExecArray{ret}
}

type ProjectsConnectionParams struct {
	Where   *ProjectWhereInput   `json:"where,omitempty"`
	OrderBy *ProjectOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ProjectConnection) Nodes() []Project {
	var nodes []Project
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ProjectConnection) NodesPtr() []*Project {
	var nodes []*Project
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ProjectsConnection(params *ProjectsConnectionParams) *ProjectConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProjectWhereInput", "ProjectOrderByInput", "Project"},
		"projectsConnection",
		[]string{"edges", "pageInfo"})

	return &ProjectConnectionExec{ret}
}

func (client *Client) Session(params SessionWhereUniqueInput) *SessionExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"SessionWhereUniqueInput!", "Session"},
		"session",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

type SessionsParams struct {
	Where   *SessionWhereInput   `json:"where,omitempty"`
	OrderBy *SessionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Sessions(params *SessionsParams) *SessionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SessionWhereInput", "SessionOrderByInput", "Session"},
		"sessions",
		[]string{"id", "createdAt"})

	return &SessionExecArray{ret}
}

type SessionsConnectionParams struct {
	Where   *SessionWhereInput   `json:"where,omitempty"`
	OrderBy *SessionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *SessionConnection) Nodes() []Session {
	var nodes []Session
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *SessionConnection) NodesPtr() []*Session {
	var nodes []*Session
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) SessionsConnection(params *SessionsConnectionParams) *SessionConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SessionWhereInput", "SessionOrderByInput", "Session"},
		"sessionsConnection",
		[]string{"edges", "pageInfo"})

	return &SessionConnectionExec{ret}
}

func (client *Client) Subscriber(params SubscriberWhereUniqueInput) *SubscriberExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"SubscriberWhereUniqueInput!", "Subscriber"},
		"subscriber",
		[]string{"id", "email", "name", "confirmed", "unsubscribed"})

	return &SubscriberExec{ret}
}

type SubscribersParams struct {
	Where   *SubscriberWhereInput   `json:"where,omitempty"`
	OrderBy *SubscriberOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) Subscribers(params *SubscribersParams) *SubscriberExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SubscriberWhereInput", "SubscriberOrderByInput", "Subscriber"},
		"subscribers",
		[]string{"id", "email", "name", "confirmed", "unsubscribed"})

	return &SubscriberExecArray{ret}
}

type SubscribersConnectionParams struct {
	Where   *SubscriberWhereInput   `json:"where,omitempty"`
	OrderBy *SubscriberOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *SubscriberConnection) Nodes() []Subscriber {
	var nodes []Subscriber
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *SubscriberConnection) NodesPtr() []*Subscriber {
	var nodes []*Subscriber
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) SubscribersConnection(params *SubscribersConnectionParams) *SubscriberConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"SubscriberWhereInput", "SubscriberOrderByInput", "Subscriber"},
		"subscribersConnection",
		[]string{"edges", "pageInfo"})

	return &SubscriberConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *UserConnection) Nodes() []User {
	var nodes []User
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *UserConnection) NodesPtr() []*User {
	var nodes []*User
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) CreateBlogPost(params BlogPostCreateInput) *BlogPostExec {
	ret := client.Client.Create(
		params,
		[2]string{"BlogPostCreateInput!", "BlogPost"},
		"createBlogPost",
		[]string{"id", "createdAt", "updatedAt", "slug", "published", "image", "title", "date", "content", "tags"})

	return &BlogPostExec{ret}
}

type BlogPostUpdateParams struct {
	Data  BlogPostUpdateInput      `json:"data"`
	Where BlogPostWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBlogPost(params BlogPostUpdateParams) *BlogPostExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BlogPostUpdateInput!", "BlogPostWhereUniqueInput!", "BlogPost"},
		"updateBlogPost",
		[]string{"id", "createdAt", "updatedAt", "slug", "published", "image", "title", "date", "content", "tags"})

	return &BlogPostExec{ret}
}

type BlogPostUpdateManyParams struct {
	Data  BlogPostUpdateManyMutationInput `json:"data"`
	Where *BlogPostWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBlogPosts(params BlogPostUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BlogPostUpdateManyMutationInput!", "BlogPostWhereInput"},
		"updateManyBlogPosts")
	return &BatchPayloadExec{exec}
}

type BlogPostUpsertParams struct {
	Where  BlogPostWhereUniqueInput `json:"where"`
	Create BlogPostCreateInput      `json:"create"`
	Update BlogPostUpdateInput      `json:"update"`
}

func (client *Client) UpsertBlogPost(params BlogPostUpsertParams) *BlogPostExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BlogPostWhereUniqueInput!", "BlogPostCreateInput!", "BlogPostUpdateInput!", "BlogPost"},
		"upsertBlogPost",
		[]string{"id", "createdAt", "updatedAt", "slug", "published", "image", "title", "date", "content", "tags"})

	return &BlogPostExec{ret}
}

func (client *Client) DeleteBlogPost(params BlogPostWhereUniqueInput) *BlogPostExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BlogPostWhereUniqueInput!", "BlogPost"},
		"deleteBlogPost",
		[]string{"id", "createdAt", "updatedAt", "slug", "published", "image", "title", "date", "content", "tags"})

	return &BlogPostExec{ret}
}

func (client *Client) DeleteManyBlogPosts(params *BlogPostWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BlogPostWhereInput", "deleteManyBlogPosts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateBook(params BookCreateInput) *BookExec {
	ret := client.Client.Create(
		params,
		[2]string{"BookCreateInput!", "Book"},
		"createBook",
		[]string{"id", "title", "author", "rank", "link"})

	return &BookExec{ret}
}

type BookUpdateParams struct {
	Data  BookUpdateInput      `json:"data"`
	Where BookWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBook(params BookUpdateParams) *BookExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BookUpdateInput!", "BookWhereUniqueInput!", "Book"},
		"updateBook",
		[]string{"id", "title", "author", "rank", "link"})

	return &BookExec{ret}
}

type BookUpdateManyParams struct {
	Data  BookUpdateManyMutationInput `json:"data"`
	Where *BookWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBooks(params BookUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BookUpdateManyMutationInput!", "BookWhereInput"},
		"updateManyBooks")
	return &BatchPayloadExec{exec}
}

type BookUpsertParams struct {
	Where  BookWhereUniqueInput `json:"where"`
	Create BookCreateInput      `json:"create"`
	Update BookUpdateInput      `json:"update"`
}

func (client *Client) UpsertBook(params BookUpsertParams) *BookExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BookWhereUniqueInput!", "BookCreateInput!", "BookUpdateInput!", "Book"},
		"upsertBook",
		[]string{"id", "title", "author", "rank", "link"})

	return &BookExec{ret}
}

func (client *Client) DeleteBook(params BookWhereUniqueInput) *BookExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BookWhereUniqueInput!", "Book"},
		"deleteBook",
		[]string{"id", "title", "author", "rank", "link"})

	return &BookExec{ret}
}

func (client *Client) DeleteManyBooks(params *BookWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BookWhereInput", "deleteManyBooks")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFavoriteThing(params FavoriteThingCreateInput) *FavoriteThingExec {
	ret := client.Client.Create(
		params,
		[2]string{"FavoriteThingCreateInput!", "FavoriteThing"},
		"createFavoriteThing",
		[]string{"id", "priority", "name", "link", "description"})

	return &FavoriteThingExec{ret}
}

type FavoriteThingUpdateParams struct {
	Data  FavoriteThingUpdateInput      `json:"data"`
	Where FavoriteThingWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateFavoriteThing(params FavoriteThingUpdateParams) *FavoriteThingExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"FavoriteThingUpdateInput!", "FavoriteThingWhereUniqueInput!", "FavoriteThing"},
		"updateFavoriteThing",
		[]string{"id", "priority", "name", "link", "description"})

	return &FavoriteThingExec{ret}
}

type FavoriteThingUpdateManyParams struct {
	Data  FavoriteThingUpdateManyMutationInput `json:"data"`
	Where *FavoriteThingWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyFavoriteThings(params FavoriteThingUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"FavoriteThingUpdateManyMutationInput!", "FavoriteThingWhereInput"},
		"updateManyFavoriteThings")
	return &BatchPayloadExec{exec}
}

type FavoriteThingUpsertParams struct {
	Where  FavoriteThingWhereUniqueInput `json:"where"`
	Create FavoriteThingCreateInput      `json:"create"`
	Update FavoriteThingUpdateInput      `json:"update"`
}

func (client *Client) UpsertFavoriteThing(params FavoriteThingUpsertParams) *FavoriteThingExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"FavoriteThingWhereUniqueInput!", "FavoriteThingCreateInput!", "FavoriteThingUpdateInput!", "FavoriteThing"},
		"upsertFavoriteThing",
		[]string{"id", "priority", "name", "link", "description"})

	return &FavoriteThingExec{ret}
}

func (client *Client) DeleteFavoriteThing(params FavoriteThingWhereUniqueInput) *FavoriteThingExec {
	ret := client.Client.Delete(
		params,
		[2]string{"FavoriteThingWhereUniqueInput!", "FavoriteThing"},
		"deleteFavoriteThing",
		[]string{"id", "priority", "name", "link", "description"})

	return &FavoriteThingExec{ret}
}

func (client *Client) DeleteManyFavoriteThings(params *FavoriteThingWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FavoriteThingWhereInput", "deleteManyFavoriteThings")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateNewsletterSend(params NewsletterSendCreateInput) *NewsletterSendExec {
	ret := client.Client.Create(
		params,
		[2]string{"NewsletterSendCreateInput!", "NewsletterSend"},
		"createNewsletterSend",
		[]string{"id", "key", "createdAt", "recipients", "description"})

	return &NewsletterSendExec{ret}
}

type NewsletterSendUpdateParams struct {
	Data  NewsletterSendUpdateInput      `json:"data"`
	Where NewsletterSendWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateNewsletterSend(params NewsletterSendUpdateParams) *NewsletterSendExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"NewsletterSendUpdateInput!", "NewsletterSendWhereUniqueInput!", "NewsletterSend"},
		"updateNewsletterSend",
		[]string{"id", "key", "createdAt", "recipients", "description"})

	return &NewsletterSendExec{ret}
}

type NewsletterSendUpdateManyParams struct {
	Data  NewsletterSendUpdateManyMutationInput `json:"data"`
	Where *NewsletterSendWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyNewsletterSends(params NewsletterSendUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"NewsletterSendUpdateManyMutationInput!", "NewsletterSendWhereInput"},
		"updateManyNewsletterSends")
	return &BatchPayloadExec{exec}
}

type NewsletterSendUpsertParams struct {
	Where  NewsletterSendWhereUniqueInput `json:"where"`
	Create NewsletterSendCreateInput      `json:"create"`
	Update NewsletterSendUpdateInput      `json:"update"`
}

func (client *Client) UpsertNewsletterSend(params NewsletterSendUpsertParams) *NewsletterSendExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"NewsletterSendWhereUniqueInput!", "NewsletterSendCreateInput!", "NewsletterSendUpdateInput!", "NewsletterSend"},
		"upsertNewsletterSend",
		[]string{"id", "key", "createdAt", "recipients", "description"})

	return &NewsletterSendExec{ret}
}

func (client *Client) DeleteNewsletterSend(params NewsletterSendWhereUniqueInput) *NewsletterSendExec {
	ret := client.Client.Delete(
		params,
		[2]string{"NewsletterSendWhereUniqueInput!", "NewsletterSend"},
		"deleteNewsletterSend",
		[]string{"id", "key", "createdAt", "recipients", "description"})

	return &NewsletterSendExec{ret}
}

func (client *Client) DeleteManyNewsletterSends(params *NewsletterSendWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "NewsletterSendWhereInput", "deleteManyNewsletterSends")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateProject(params ProjectCreateInput) *ProjectExec {
	ret := client.Client.Create(
		params,
		[2]string{"ProjectCreateInput!", "Project"},
		"createProject",
		[]string{"id", "priority", "name", "link", "icon", "description", "retired", "revenue", "reason"})

	return &ProjectExec{ret}
}

type ProjectUpdateParams struct {
	Data  ProjectUpdateInput      `json:"data"`
	Where ProjectWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateProject(params ProjectUpdateParams) *ProjectExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ProjectUpdateInput!", "ProjectWhereUniqueInput!", "Project"},
		"updateProject",
		[]string{"id", "priority", "name", "link", "icon", "description", "retired", "revenue", "reason"})

	return &ProjectExec{ret}
}

type ProjectUpdateManyParams struct {
	Data  ProjectUpdateManyMutationInput `json:"data"`
	Where *ProjectWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyProjects(params ProjectUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ProjectUpdateManyMutationInput!", "ProjectWhereInput"},
		"updateManyProjects")
	return &BatchPayloadExec{exec}
}

type ProjectUpsertParams struct {
	Where  ProjectWhereUniqueInput `json:"where"`
	Create ProjectCreateInput      `json:"create"`
	Update ProjectUpdateInput      `json:"update"`
}

func (client *Client) UpsertProject(params ProjectUpsertParams) *ProjectExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ProjectWhereUniqueInput!", "ProjectCreateInput!", "ProjectUpdateInput!", "Project"},
		"upsertProject",
		[]string{"id", "priority", "name", "link", "icon", "description", "retired", "revenue", "reason"})

	return &ProjectExec{ret}
}

func (client *Client) DeleteProject(params ProjectWhereUniqueInput) *ProjectExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ProjectWhereUniqueInput!", "Project"},
		"deleteProject",
		[]string{"id", "priority", "name", "link", "icon", "description", "retired", "revenue", "reason"})

	return &ProjectExec{ret}
}

func (client *Client) DeleteManyProjects(params *ProjectWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ProjectWhereInput", "deleteManyProjects")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateSession(params SessionCreateInput) *SessionExec {
	ret := client.Client.Create(
		params,
		[2]string{"SessionCreateInput!", "Session"},
		"createSession",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

type SessionUpdateParams struct {
	Data  SessionUpdateInput      `json:"data"`
	Where SessionWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateSession(params SessionUpdateParams) *SessionExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"SessionUpdateInput!", "SessionWhereUniqueInput!", "Session"},
		"updateSession",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

type SessionUpsertParams struct {
	Where  SessionWhereUniqueInput `json:"where"`
	Create SessionCreateInput      `json:"create"`
	Update SessionUpdateInput      `json:"update"`
}

func (client *Client) UpsertSession(params SessionUpsertParams) *SessionExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"SessionWhereUniqueInput!", "SessionCreateInput!", "SessionUpdateInput!", "Session"},
		"upsertSession",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

func (client *Client) DeleteSession(params SessionWhereUniqueInput) *SessionExec {
	ret := client.Client.Delete(
		params,
		[2]string{"SessionWhereUniqueInput!", "Session"},
		"deleteSession",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

func (client *Client) DeleteManySessions(params *SessionWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "SessionWhereInput", "deleteManySessions")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateSubscriber(params SubscriberCreateInput) *SubscriberExec {
	ret := client.Client.Create(
		params,
		[2]string{"SubscriberCreateInput!", "Subscriber"},
		"createSubscriber",
		[]string{"id", "email", "name", "confirmed", "unsubscribed"})

	return &SubscriberExec{ret}
}

type SubscriberUpdateParams struct {
	Data  SubscriberUpdateInput      `json:"data"`
	Where SubscriberWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateSubscriber(params SubscriberUpdateParams) *SubscriberExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"SubscriberUpdateInput!", "SubscriberWhereUniqueInput!", "Subscriber"},
		"updateSubscriber",
		[]string{"id", "email", "name", "confirmed", "unsubscribed"})

	return &SubscriberExec{ret}
}

type SubscriberUpdateManyParams struct {
	Data  SubscriberUpdateManyMutationInput `json:"data"`
	Where *SubscriberWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManySubscribers(params SubscriberUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"SubscriberUpdateManyMutationInput!", "SubscriberWhereInput"},
		"updateManySubscribers")
	return &BatchPayloadExec{exec}
}

type SubscriberUpsertParams struct {
	Where  SubscriberWhereUniqueInput `json:"where"`
	Create SubscriberCreateInput      `json:"create"`
	Update SubscriberUpdateInput      `json:"update"`
}

func (client *Client) UpsertSubscriber(params SubscriberUpsertParams) *SubscriberExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"SubscriberWhereUniqueInput!", "SubscriberCreateInput!", "SubscriberUpdateInput!", "Subscriber"},
		"upsertSubscriber",
		[]string{"id", "email", "name", "confirmed", "unsubscribed"})

	return &SubscriberExec{ret}
}

func (client *Client) DeleteSubscriber(params SubscriberWhereUniqueInput) *SubscriberExec {
	ret := client.Client.Delete(
		params,
		[2]string{"SubscriberWhereUniqueInput!", "Subscriber"},
		"deleteSubscriber",
		[]string{"id", "email", "name", "confirmed", "unsubscribed"})

	return &SubscriberExec{ret}
}

func (client *Client) DeleteManySubscribers(params *SubscriberWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "SubscriberWhereInput", "deleteManySubscribers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type BlogPostOrderByInput string

const (
	BlogPostOrderByInputIDAsc         BlogPostOrderByInput = "id_ASC"
	BlogPostOrderByInputIDDesc        BlogPostOrderByInput = "id_DESC"
	BlogPostOrderByInputCreatedAtAsc  BlogPostOrderByInput = "createdAt_ASC"
	BlogPostOrderByInputCreatedAtDesc BlogPostOrderByInput = "createdAt_DESC"
	BlogPostOrderByInputUpdatedAtAsc  BlogPostOrderByInput = "updatedAt_ASC"
	BlogPostOrderByInputUpdatedAtDesc BlogPostOrderByInput = "updatedAt_DESC"
	BlogPostOrderByInputSlugAsc       BlogPostOrderByInput = "slug_ASC"
	BlogPostOrderByInputSlugDesc      BlogPostOrderByInput = "slug_DESC"
	BlogPostOrderByInputPublishedAsc  BlogPostOrderByInput = "published_ASC"
	BlogPostOrderByInputPublishedDesc BlogPostOrderByInput = "published_DESC"
	BlogPostOrderByInputImageAsc      BlogPostOrderByInput = "image_ASC"
	BlogPostOrderByInputImageDesc     BlogPostOrderByInput = "image_DESC"
	BlogPostOrderByInputTitleAsc      BlogPostOrderByInput = "title_ASC"
	BlogPostOrderByInputTitleDesc     BlogPostOrderByInput = "title_DESC"
	BlogPostOrderByInputDateAsc       BlogPostOrderByInput = "date_ASC"
	BlogPostOrderByInputDateDesc      BlogPostOrderByInput = "date_DESC"
	BlogPostOrderByInputContentAsc    BlogPostOrderByInput = "content_ASC"
	BlogPostOrderByInputContentDesc   BlogPostOrderByInput = "content_DESC"
	BlogPostOrderByInputTagsAsc       BlogPostOrderByInput = "tags_ASC"
	BlogPostOrderByInputTagsDesc      BlogPostOrderByInput = "tags_DESC"
)

type BookOrderByInput string

const (
	BookOrderByInputIDAsc      BookOrderByInput = "id_ASC"
	BookOrderByInputIDDesc     BookOrderByInput = "id_DESC"
	BookOrderByInputTitleAsc   BookOrderByInput = "title_ASC"
	BookOrderByInputTitleDesc  BookOrderByInput = "title_DESC"
	BookOrderByInputAuthorAsc  BookOrderByInput = "author_ASC"
	BookOrderByInputAuthorDesc BookOrderByInput = "author_DESC"
	BookOrderByInputRankAsc    BookOrderByInput = "rank_ASC"
	BookOrderByInputRankDesc   BookOrderByInput = "rank_DESC"
	BookOrderByInputLinkAsc    BookOrderByInput = "link_ASC"
	BookOrderByInputLinkDesc   BookOrderByInput = "link_DESC"
)

type FavoriteThingOrderByInput string

const (
	FavoriteThingOrderByInputIDAsc           FavoriteThingOrderByInput = "id_ASC"
	FavoriteThingOrderByInputIDDesc          FavoriteThingOrderByInput = "id_DESC"
	FavoriteThingOrderByInputPriorityAsc     FavoriteThingOrderByInput = "priority_ASC"
	FavoriteThingOrderByInputPriorityDesc    FavoriteThingOrderByInput = "priority_DESC"
	FavoriteThingOrderByInputNameAsc         FavoriteThingOrderByInput = "name_ASC"
	FavoriteThingOrderByInputNameDesc        FavoriteThingOrderByInput = "name_DESC"
	FavoriteThingOrderByInputLinkAsc         FavoriteThingOrderByInput = "link_ASC"
	FavoriteThingOrderByInputLinkDesc        FavoriteThingOrderByInput = "link_DESC"
	FavoriteThingOrderByInputDescriptionAsc  FavoriteThingOrderByInput = "description_ASC"
	FavoriteThingOrderByInputDescriptionDesc FavoriteThingOrderByInput = "description_DESC"
)

type UserType string

const (
	UserTypeAdmin UserType = "ADMIN"
	UserTypeGuest UserType = "GUEST"
)

type NewsletterSendOrderByInput string

const (
	NewsletterSendOrderByInputIDAsc           NewsletterSendOrderByInput = "id_ASC"
	NewsletterSendOrderByInputIDDesc          NewsletterSendOrderByInput = "id_DESC"
	NewsletterSendOrderByInputKeyAsc          NewsletterSendOrderByInput = "key_ASC"
	NewsletterSendOrderByInputKeyDesc         NewsletterSendOrderByInput = "key_DESC"
	NewsletterSendOrderByInputCreatedAtAsc    NewsletterSendOrderByInput = "createdAt_ASC"
	NewsletterSendOrderByInputCreatedAtDesc   NewsletterSendOrderByInput = "createdAt_DESC"
	NewsletterSendOrderByInputRecipientsAsc   NewsletterSendOrderByInput = "recipients_ASC"
	NewsletterSendOrderByInputRecipientsDesc  NewsletterSendOrderByInput = "recipients_DESC"
	NewsletterSendOrderByInputDescriptionAsc  NewsletterSendOrderByInput = "description_ASC"
	NewsletterSendOrderByInputDescriptionDesc NewsletterSendOrderByInput = "description_DESC"
)

type ProjectOrderByInput string

const (
	ProjectOrderByInputIDAsc           ProjectOrderByInput = "id_ASC"
	ProjectOrderByInputIDDesc          ProjectOrderByInput = "id_DESC"
	ProjectOrderByInputPriorityAsc     ProjectOrderByInput = "priority_ASC"
	ProjectOrderByInputPriorityDesc    ProjectOrderByInput = "priority_DESC"
	ProjectOrderByInputNameAsc         ProjectOrderByInput = "name_ASC"
	ProjectOrderByInputNameDesc        ProjectOrderByInput = "name_DESC"
	ProjectOrderByInputLinkAsc         ProjectOrderByInput = "link_ASC"
	ProjectOrderByInputLinkDesc        ProjectOrderByInput = "link_DESC"
	ProjectOrderByInputIconAsc         ProjectOrderByInput = "icon_ASC"
	ProjectOrderByInputIconDesc        ProjectOrderByInput = "icon_DESC"
	ProjectOrderByInputDescriptionAsc  ProjectOrderByInput = "description_ASC"
	ProjectOrderByInputDescriptionDesc ProjectOrderByInput = "description_DESC"
	ProjectOrderByInputRetiredAsc      ProjectOrderByInput = "retired_ASC"
	ProjectOrderByInputRetiredDesc     ProjectOrderByInput = "retired_DESC"
	ProjectOrderByInputRevenueAsc      ProjectOrderByInput = "revenue_ASC"
	ProjectOrderByInputRevenueDesc     ProjectOrderByInput = "revenue_DESC"
	ProjectOrderByInputReasonAsc       ProjectOrderByInput = "reason_ASC"
	ProjectOrderByInputReasonDesc      ProjectOrderByInput = "reason_DESC"
)

type SessionOrderByInput string

const (
	SessionOrderByInputIDAsc         SessionOrderByInput = "id_ASC"
	SessionOrderByInputIDDesc        SessionOrderByInput = "id_DESC"
	SessionOrderByInputCreatedAtAsc  SessionOrderByInput = "createdAt_ASC"
	SessionOrderByInputCreatedAtDesc SessionOrderByInput = "createdAt_DESC"
)

type SubscriberOrderByInput string

const (
	SubscriberOrderByInputIDAsc            SubscriberOrderByInput = "id_ASC"
	SubscriberOrderByInputIDDesc           SubscriberOrderByInput = "id_DESC"
	SubscriberOrderByInputEmailAsc         SubscriberOrderByInput = "email_ASC"
	SubscriberOrderByInputEmailDesc        SubscriberOrderByInput = "email_DESC"
	SubscriberOrderByInputNameAsc          SubscriberOrderByInput = "name_ASC"
	SubscriberOrderByInputNameDesc         SubscriberOrderByInput = "name_DESC"
	SubscriberOrderByInputConfirmedAsc     SubscriberOrderByInput = "confirmed_ASC"
	SubscriberOrderByInputConfirmedDesc    SubscriberOrderByInput = "confirmed_DESC"
	SubscriberOrderByInputUnsubscribedAsc  SubscriberOrderByInput = "unsubscribed_ASC"
	SubscriberOrderByInputUnsubscribedDesc SubscriberOrderByInput = "unsubscribed_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc            UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc           UserOrderByInput = "id_DESC"
	UserOrderByInputTypeAsc          UserOrderByInput = "type_ASC"
	UserOrderByInputTypeDesc         UserOrderByInput = "type_DESC"
	UserOrderByInputCreatedAtAsc     UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc    UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc     UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc    UserOrderByInput = "updatedAt_DESC"
	UserOrderByInputEmailAsc         UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc        UserOrderByInput = "email_DESC"
	UserOrderByInputNameAsc          UserOrderByInput = "name_ASC"
	UserOrderByInputNameDesc         UserOrderByInput = "name_DESC"
	UserOrderByInputPasswordHashAsc  UserOrderByInput = "passwordHash_ASC"
	UserOrderByInputPasswordHashDesc UserOrderByInput = "passwordHash_DESC"
)

type BlogPostWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

type ProjectWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BlogPostCreateInput struct {
	ID        *string            `json:"id,omitempty"`
	Slug      string             `json:"slug"`
	Published bool               `json:"published"`
	Image     string             `json:"image"`
	Title     string             `json:"title"`
	Date      string             `json:"date"`
	Author    UserCreateOneInput `json:"author"`
	Content   string             `json:"content"`
	Tags      string             `json:"tags"`
}

type ProjectUpdateInput struct {
	Priority    *int32  `json:"priority,omitempty"`
	Name        *string `json:"name,omitempty"`
	Link        *string `json:"link,omitempty"`
	Icon        *string `json:"icon,omitempty"`
	Description *string `json:"description,omitempty"`
	Retired     *bool   `json:"retired,omitempty"`
	Revenue     *string `json:"revenue,omitempty"`
	Reason      *string `json:"reason,omitempty"`
}

type SubscriberSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *SubscriberWhereInput              `json:"node,omitempty"`
	And                        []SubscriberSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []SubscriberSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []SubscriberSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ProjectWhereInput struct {
	ID                       *string             `json:"id,omitempty"`
	IDNot                    *string             `json:"id_not,omitempty"`
	IDIn                     []string            `json:"id_in,omitempty"`
	IDNotIn                  []string            `json:"id_not_in,omitempty"`
	IDLt                     *string             `json:"id_lt,omitempty"`
	IDLte                    *string             `json:"id_lte,omitempty"`
	IDGt                     *string             `json:"id_gt,omitempty"`
	IDGte                    *string             `json:"id_gte,omitempty"`
	IDContains               *string             `json:"id_contains,omitempty"`
	IDNotContains            *string             `json:"id_not_contains,omitempty"`
	IDStartsWith             *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string             `json:"id_not_ends_with,omitempty"`
	Priority                 *int32              `json:"priority,omitempty"`
	PriorityNot              *int32              `json:"priority_not,omitempty"`
	PriorityIn               []int32             `json:"priority_in,omitempty"`
	PriorityNotIn            []int32             `json:"priority_not_in,omitempty"`
	PriorityLt               *int32              `json:"priority_lt,omitempty"`
	PriorityLte              *int32              `json:"priority_lte,omitempty"`
	PriorityGt               *int32              `json:"priority_gt,omitempty"`
	PriorityGte              *int32              `json:"priority_gte,omitempty"`
	Name                     *string             `json:"name,omitempty"`
	NameNot                  *string             `json:"name_not,omitempty"`
	NameIn                   []string            `json:"name_in,omitempty"`
	NameNotIn                []string            `json:"name_not_in,omitempty"`
	NameLt                   *string             `json:"name_lt,omitempty"`
	NameLte                  *string             `json:"name_lte,omitempty"`
	NameGt                   *string             `json:"name_gt,omitempty"`
	NameGte                  *string             `json:"name_gte,omitempty"`
	NameContains             *string             `json:"name_contains,omitempty"`
	NameNotContains          *string             `json:"name_not_contains,omitempty"`
	NameStartsWith           *string             `json:"name_starts_with,omitempty"`
	NameNotStartsWith        *string             `json:"name_not_starts_with,omitempty"`
	NameEndsWith             *string             `json:"name_ends_with,omitempty"`
	NameNotEndsWith          *string             `json:"name_not_ends_with,omitempty"`
	Link                     *string             `json:"link,omitempty"`
	LinkNot                  *string             `json:"link_not,omitempty"`
	LinkIn                   []string            `json:"link_in,omitempty"`
	LinkNotIn                []string            `json:"link_not_in,omitempty"`
	LinkLt                   *string             `json:"link_lt,omitempty"`
	LinkLte                  *string             `json:"link_lte,omitempty"`
	LinkGt                   *string             `json:"link_gt,omitempty"`
	LinkGte                  *string             `json:"link_gte,omitempty"`
	LinkContains             *string             `json:"link_contains,omitempty"`
	LinkNotContains          *string             `json:"link_not_contains,omitempty"`
	LinkStartsWith           *string             `json:"link_starts_with,omitempty"`
	LinkNotStartsWith        *string             `json:"link_not_starts_with,omitempty"`
	LinkEndsWith             *string             `json:"link_ends_with,omitempty"`
	LinkNotEndsWith          *string             `json:"link_not_ends_with,omitempty"`
	Icon                     *string             `json:"icon,omitempty"`
	IconNot                  *string             `json:"icon_not,omitempty"`
	IconIn                   []string            `json:"icon_in,omitempty"`
	IconNotIn                []string            `json:"icon_not_in,omitempty"`
	IconLt                   *string             `json:"icon_lt,omitempty"`
	IconLte                  *string             `json:"icon_lte,omitempty"`
	IconGt                   *string             `json:"icon_gt,omitempty"`
	IconGte                  *string             `json:"icon_gte,omitempty"`
	IconContains             *string             `json:"icon_contains,omitempty"`
	IconNotContains          *string             `json:"icon_not_contains,omitempty"`
	IconStartsWith           *string             `json:"icon_starts_with,omitempty"`
	IconNotStartsWith        *string             `json:"icon_not_starts_with,omitempty"`
	IconEndsWith             *string             `json:"icon_ends_with,omitempty"`
	IconNotEndsWith          *string             `json:"icon_not_ends_with,omitempty"`
	Description              *string             `json:"description,omitempty"`
	DescriptionNot           *string             `json:"description_not,omitempty"`
	DescriptionIn            []string            `json:"description_in,omitempty"`
	DescriptionNotIn         []string            `json:"description_not_in,omitempty"`
	DescriptionLt            *string             `json:"description_lt,omitempty"`
	DescriptionLte           *string             `json:"description_lte,omitempty"`
	DescriptionGt            *string             `json:"description_gt,omitempty"`
	DescriptionGte           *string             `json:"description_gte,omitempty"`
	DescriptionContains      *string             `json:"description_contains,omitempty"`
	DescriptionNotContains   *string             `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string             `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string             `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string             `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string             `json:"description_not_ends_with,omitempty"`
	Retired                  *bool               `json:"retired,omitempty"`
	RetiredNot               *bool               `json:"retired_not,omitempty"`
	Revenue                  *string             `json:"revenue,omitempty"`
	RevenueNot               *string             `json:"revenue_not,omitempty"`
	RevenueIn                []string            `json:"revenue_in,omitempty"`
	RevenueNotIn             []string            `json:"revenue_not_in,omitempty"`
	RevenueLt                *string             `json:"revenue_lt,omitempty"`
	RevenueLte               *string             `json:"revenue_lte,omitempty"`
	RevenueGt                *string             `json:"revenue_gt,omitempty"`
	RevenueGte               *string             `json:"revenue_gte,omitempty"`
	RevenueContains          *string             `json:"revenue_contains,omitempty"`
	RevenueNotContains       *string             `json:"revenue_not_contains,omitempty"`
	RevenueStartsWith        *string             `json:"revenue_starts_with,omitempty"`
	RevenueNotStartsWith     *string             `json:"revenue_not_starts_with,omitempty"`
	RevenueEndsWith          *string             `json:"revenue_ends_with,omitempty"`
	RevenueNotEndsWith       *string             `json:"revenue_not_ends_with,omitempty"`
	Reason                   *string             `json:"reason,omitempty"`
	ReasonNot                *string             `json:"reason_not,omitempty"`
	ReasonIn                 []string            `json:"reason_in,omitempty"`
	ReasonNotIn              []string            `json:"reason_not_in,omitempty"`
	ReasonLt                 *string             `json:"reason_lt,omitempty"`
	ReasonLte                *string             `json:"reason_lte,omitempty"`
	ReasonGt                 *string             `json:"reason_gt,omitempty"`
	ReasonGte                *string             `json:"reason_gte,omitempty"`
	ReasonContains           *string             `json:"reason_contains,omitempty"`
	ReasonNotContains        *string             `json:"reason_not_contains,omitempty"`
	ReasonStartsWith         *string             `json:"reason_starts_with,omitempty"`
	ReasonNotStartsWith      *string             `json:"reason_not_starts_with,omitempty"`
	ReasonEndsWith           *string             `json:"reason_ends_with,omitempty"`
	ReasonNotEndsWith        *string             `json:"reason_not_ends_with,omitempty"`
	And                      []ProjectWhereInput `json:"AND,omitempty"`
	Or                       []ProjectWhereInput `json:"OR,omitempty"`
	Not                      []ProjectWhereInput `json:"NOT,omitempty"`
}

type BookWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ProjectCreateInput struct {
	ID          *string `json:"id,omitempty"`
	Priority    int32   `json:"priority"`
	Name        string  `json:"name"`
	Link        string  `json:"link"`
	Icon        string  `json:"icon"`
	Description string  `json:"description"`
	Retired     bool    `json:"retired"`
	Revenue     string  `json:"revenue"`
	Reason      *string `json:"reason,omitempty"`
}

type BookWhereInput struct {
	ID                  *string          `json:"id,omitempty"`
	IDNot               *string          `json:"id_not,omitempty"`
	IDIn                []string         `json:"id_in,omitempty"`
	IDNotIn             []string         `json:"id_not_in,omitempty"`
	IDLt                *string          `json:"id_lt,omitempty"`
	IDLte               *string          `json:"id_lte,omitempty"`
	IDGt                *string          `json:"id_gt,omitempty"`
	IDGte               *string          `json:"id_gte,omitempty"`
	IDContains          *string          `json:"id_contains,omitempty"`
	IDNotContains       *string          `json:"id_not_contains,omitempty"`
	IDStartsWith        *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string          `json:"id_not_ends_with,omitempty"`
	Title               *string          `json:"title,omitempty"`
	TitleNot            *string          `json:"title_not,omitempty"`
	TitleIn             []string         `json:"title_in,omitempty"`
	TitleNotIn          []string         `json:"title_not_in,omitempty"`
	TitleLt             *string          `json:"title_lt,omitempty"`
	TitleLte            *string          `json:"title_lte,omitempty"`
	TitleGt             *string          `json:"title_gt,omitempty"`
	TitleGte            *string          `json:"title_gte,omitempty"`
	TitleContains       *string          `json:"title_contains,omitempty"`
	TitleNotContains    *string          `json:"title_not_contains,omitempty"`
	TitleStartsWith     *string          `json:"title_starts_with,omitempty"`
	TitleNotStartsWith  *string          `json:"title_not_starts_with,omitempty"`
	TitleEndsWith       *string          `json:"title_ends_with,omitempty"`
	TitleNotEndsWith    *string          `json:"title_not_ends_with,omitempty"`
	Author              *string          `json:"author,omitempty"`
	AuthorNot           *string          `json:"author_not,omitempty"`
	AuthorIn            []string         `json:"author_in,omitempty"`
	AuthorNotIn         []string         `json:"author_not_in,omitempty"`
	AuthorLt            *string          `json:"author_lt,omitempty"`
	AuthorLte           *string          `json:"author_lte,omitempty"`
	AuthorGt            *string          `json:"author_gt,omitempty"`
	AuthorGte           *string          `json:"author_gte,omitempty"`
	AuthorContains      *string          `json:"author_contains,omitempty"`
	AuthorNotContains   *string          `json:"author_not_contains,omitempty"`
	AuthorStartsWith    *string          `json:"author_starts_with,omitempty"`
	AuthorNotStartsWith *string          `json:"author_not_starts_with,omitempty"`
	AuthorEndsWith      *string          `json:"author_ends_with,omitempty"`
	AuthorNotEndsWith   *string          `json:"author_not_ends_with,omitempty"`
	Rank                *int32           `json:"rank,omitempty"`
	RankNot             *int32           `json:"rank_not,omitempty"`
	RankIn              []int32          `json:"rank_in,omitempty"`
	RankNotIn           []int32          `json:"rank_not_in,omitempty"`
	RankLt              *int32           `json:"rank_lt,omitempty"`
	RankLte             *int32           `json:"rank_lte,omitempty"`
	RankGt              *int32           `json:"rank_gt,omitempty"`
	RankGte             *int32           `json:"rank_gte,omitempty"`
	Link                *string          `json:"link,omitempty"`
	LinkNot             *string          `json:"link_not,omitempty"`
	LinkIn              []string         `json:"link_in,omitempty"`
	LinkNotIn           []string         `json:"link_not_in,omitempty"`
	LinkLt              *string          `json:"link_lt,omitempty"`
	LinkLte             *string          `json:"link_lte,omitempty"`
	LinkGt              *string          `json:"link_gt,omitempty"`
	LinkGte             *string          `json:"link_gte,omitempty"`
	LinkContains        *string          `json:"link_contains,omitempty"`
	LinkNotContains     *string          `json:"link_not_contains,omitempty"`
	LinkStartsWith      *string          `json:"link_starts_with,omitempty"`
	LinkNotStartsWith   *string          `json:"link_not_starts_with,omitempty"`
	LinkEndsWith        *string          `json:"link_ends_with,omitempty"`
	LinkNotEndsWith     *string          `json:"link_not_ends_with,omitempty"`
	And                 []BookWhereInput `json:"AND,omitempty"`
	Or                  []BookWhereInput `json:"OR,omitempty"`
	Not                 []BookWhereInput `json:"NOT,omitempty"`
}

type NewsletterSendUpdateManyMutationInput struct {
	Key         *string `json:"key,omitempty"`
	Recipients  *int32  `json:"recipients,omitempty"`
	Description *string `json:"description,omitempty"`
}

type NewsletterSendSubscriptionWhereInput struct {
	MutationIn                 []MutationType                         `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                               `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                               `json:"updatedFields_contains_some,omitempty"`
	Node                       *NewsletterSendWhereInput              `json:"node,omitempty"`
	And                        []NewsletterSendSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []NewsletterSendSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []NewsletterSendSubscriptionWhereInput `json:"NOT,omitempty"`
}

type NewsletterSendUpdateInput struct {
	Key         *string `json:"key,omitempty"`
	Recipients  *int32  `json:"recipients,omitempty"`
	Description *string `json:"description,omitempty"`
}

type BookSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *BookWhereInput              `json:"node,omitempty"`
	And                        []BookSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BookSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BookSubscriptionWhereInput `json:"NOT,omitempty"`
}

type NewsletterSendCreateInput struct {
	ID          *string `json:"id,omitempty"`
	Key         string  `json:"key"`
	Recipients  int32   `json:"recipients"`
	Description string  `json:"description"`
}

type BlogPostSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *BlogPostWhereInput              `json:"node,omitempty"`
	And                        []BlogPostSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BlogPostSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BlogPostSubscriptionWhereInput `json:"NOT,omitempty"`
}

type SessionWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BlogPostWhereInput struct {
	ID                   *string              `json:"id,omitempty"`
	IDNot                *string              `json:"id_not,omitempty"`
	IDIn                 []string             `json:"id_in,omitempty"`
	IDNotIn              []string             `json:"id_not_in,omitempty"`
	IDLt                 *string              `json:"id_lt,omitempty"`
	IDLte                *string              `json:"id_lte,omitempty"`
	IDGt                 *string              `json:"id_gt,omitempty"`
	IDGte                *string              `json:"id_gte,omitempty"`
	IDContains           *string              `json:"id_contains,omitempty"`
	IDNotContains        *string              `json:"id_not_contains,omitempty"`
	IDStartsWith         *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string              `json:"id_not_ends_with,omitempty"`
	CreatedAt            *string              `json:"createdAt,omitempty"`
	CreatedAtNot         *string              `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string              `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string              `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string              `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string              `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string              `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string              `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string             `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string             `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string              `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string              `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string              `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string              `json:"updatedAt_gte,omitempty"`
	Slug                 *string              `json:"slug,omitempty"`
	SlugNot              *string              `json:"slug_not,omitempty"`
	SlugIn               []string             `json:"slug_in,omitempty"`
	SlugNotIn            []string             `json:"slug_not_in,omitempty"`
	SlugLt               *string              `json:"slug_lt,omitempty"`
	SlugLte              *string              `json:"slug_lte,omitempty"`
	SlugGt               *string              `json:"slug_gt,omitempty"`
	SlugGte              *string              `json:"slug_gte,omitempty"`
	SlugContains         *string              `json:"slug_contains,omitempty"`
	SlugNotContains      *string              `json:"slug_not_contains,omitempty"`
	SlugStartsWith       *string              `json:"slug_starts_with,omitempty"`
	SlugNotStartsWith    *string              `json:"slug_not_starts_with,omitempty"`
	SlugEndsWith         *string              `json:"slug_ends_with,omitempty"`
	SlugNotEndsWith      *string              `json:"slug_not_ends_with,omitempty"`
	Published            *bool                `json:"published,omitempty"`
	PublishedNot         *bool                `json:"published_not,omitempty"`
	Image                *string              `json:"image,omitempty"`
	ImageNot             *string              `json:"image_not,omitempty"`
	ImageIn              []string             `json:"image_in,omitempty"`
	ImageNotIn           []string             `json:"image_not_in,omitempty"`
	ImageLt              *string              `json:"image_lt,omitempty"`
	ImageLte             *string              `json:"image_lte,omitempty"`
	ImageGt              *string              `json:"image_gt,omitempty"`
	ImageGte             *string              `json:"image_gte,omitempty"`
	ImageContains        *string              `json:"image_contains,omitempty"`
	ImageNotContains     *string              `json:"image_not_contains,omitempty"`
	ImageStartsWith      *string              `json:"image_starts_with,omitempty"`
	ImageNotStartsWith   *string              `json:"image_not_starts_with,omitempty"`
	ImageEndsWith        *string              `json:"image_ends_with,omitempty"`
	ImageNotEndsWith     *string              `json:"image_not_ends_with,omitempty"`
	Title                *string              `json:"title,omitempty"`
	TitleNot             *string              `json:"title_not,omitempty"`
	TitleIn              []string             `json:"title_in,omitempty"`
	TitleNotIn           []string             `json:"title_not_in,omitempty"`
	TitleLt              *string              `json:"title_lt,omitempty"`
	TitleLte             *string              `json:"title_lte,omitempty"`
	TitleGt              *string              `json:"title_gt,omitempty"`
	TitleGte             *string              `json:"title_gte,omitempty"`
	TitleContains        *string              `json:"title_contains,omitempty"`
	TitleNotContains     *string              `json:"title_not_contains,omitempty"`
	TitleStartsWith      *string              `json:"title_starts_with,omitempty"`
	TitleNotStartsWith   *string              `json:"title_not_starts_with,omitempty"`
	TitleEndsWith        *string              `json:"title_ends_with,omitempty"`
	TitleNotEndsWith     *string              `json:"title_not_ends_with,omitempty"`
	Date                 *string              `json:"date,omitempty"`
	DateNot              *string              `json:"date_not,omitempty"`
	DateIn               []string             `json:"date_in,omitempty"`
	DateNotIn            []string             `json:"date_not_in,omitempty"`
	DateLt               *string              `json:"date_lt,omitempty"`
	DateLte              *string              `json:"date_lte,omitempty"`
	DateGt               *string              `json:"date_gt,omitempty"`
	DateGte              *string              `json:"date_gte,omitempty"`
	Author               *UserWhereInput      `json:"author,omitempty"`
	Content              *string              `json:"content,omitempty"`
	ContentNot           *string              `json:"content_not,omitempty"`
	ContentIn            []string             `json:"content_in,omitempty"`
	ContentNotIn         []string             `json:"content_not_in,omitempty"`
	ContentLt            *string              `json:"content_lt,omitempty"`
	ContentLte           *string              `json:"content_lte,omitempty"`
	ContentGt            *string              `json:"content_gt,omitempty"`
	ContentGte           *string              `json:"content_gte,omitempty"`
	ContentContains      *string              `json:"content_contains,omitempty"`
	ContentNotContains   *string              `json:"content_not_contains,omitempty"`
	ContentStartsWith    *string              `json:"content_starts_with,omitempty"`
	ContentNotStartsWith *string              `json:"content_not_starts_with,omitempty"`
	ContentEndsWith      *string              `json:"content_ends_with,omitempty"`
	ContentNotEndsWith   *string              `json:"content_not_ends_with,omitempty"`
	Tags                 *string              `json:"tags,omitempty"`
	TagsNot              *string              `json:"tags_not,omitempty"`
	TagsIn               []string             `json:"tags_in,omitempty"`
	TagsNotIn            []string             `json:"tags_not_in,omitempty"`
	TagsLt               *string              `json:"tags_lt,omitempty"`
	TagsLte              *string              `json:"tags_lte,omitempty"`
	TagsGt               *string              `json:"tags_gt,omitempty"`
	TagsGte              *string              `json:"tags_gte,omitempty"`
	TagsContains         *string              `json:"tags_contains,omitempty"`
	TagsNotContains      *string              `json:"tags_not_contains,omitempty"`
	TagsStartsWith       *string              `json:"tags_starts_with,omitempty"`
	TagsNotStartsWith    *string              `json:"tags_not_starts_with,omitempty"`
	TagsEndsWith         *string              `json:"tags_ends_with,omitempty"`
	TagsNotEndsWith      *string              `json:"tags_not_ends_with,omitempty"`
	And                  []BlogPostWhereInput `json:"AND,omitempty"`
	Or                   []BlogPostWhereInput `json:"OR,omitempty"`
	Not                  []BlogPostWhereInput `json:"NOT,omitempty"`
}

type FavoriteThingUpdateManyMutationInput struct {
	Priority    *int32  `json:"priority,omitempty"`
	Name        *string `json:"name,omitempty"`
	Link        *string `json:"link,omitempty"`
	Description *string `json:"description,omitempty"`
}

type UserUpdateInput struct {
	Type         *UserType `json:"type,omitempty"`
	Email        *string   `json:"email,omitempty"`
	Name         *string   `json:"name,omitempty"`
	PasswordHash *string   `json:"passwordHash,omitempty"`
}

type SessionWhereInput struct {
	ID              *string             `json:"id,omitempty"`
	IDNot           *string             `json:"id_not,omitempty"`
	IDIn            []string            `json:"id_in,omitempty"`
	IDNotIn         []string            `json:"id_not_in,omitempty"`
	IDLt            *string             `json:"id_lt,omitempty"`
	IDLte           *string             `json:"id_lte,omitempty"`
	IDGt            *string             `json:"id_gt,omitempty"`
	IDGte           *string             `json:"id_gte,omitempty"`
	IDContains      *string             `json:"id_contains,omitempty"`
	IDNotContains   *string             `json:"id_not_contains,omitempty"`
	IDStartsWith    *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string             `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string             `json:"createdAt,omitempty"`
	CreatedAtNot    *string             `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string             `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string             `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string             `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string             `json:"createdAt_gte,omitempty"`
	User            *UserWhereInput     `json:"user,omitempty"`
	And             []SessionWhereInput `json:"AND,omitempty"`
	Or              []SessionWhereInput `json:"OR,omitempty"`
	Not             []SessionWhereInput `json:"NOT,omitempty"`
}

type NewsletterSendWhereUniqueInput struct {
	ID  *string `json:"id,omitempty"`
	Key *string `json:"key,omitempty"`
}

type FavoriteThingUpdateInput struct {
	Priority    *int32  `json:"priority,omitempty"`
	Name        *string `json:"name,omitempty"`
	Link        *string `json:"link,omitempty"`
	Description *string `json:"description,omitempty"`
}

type NewsletterSendWhereInput struct {
	ID                       *string                    `json:"id,omitempty"`
	IDNot                    *string                    `json:"id_not,omitempty"`
	IDIn                     []string                   `json:"id_in,omitempty"`
	IDNotIn                  []string                   `json:"id_not_in,omitempty"`
	IDLt                     *string                    `json:"id_lt,omitempty"`
	IDLte                    *string                    `json:"id_lte,omitempty"`
	IDGt                     *string                    `json:"id_gt,omitempty"`
	IDGte                    *string                    `json:"id_gte,omitempty"`
	IDContains               *string                    `json:"id_contains,omitempty"`
	IDNotContains            *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                    `json:"id_not_ends_with,omitempty"`
	Key                      *string                    `json:"key,omitempty"`
	KeyNot                   *string                    `json:"key_not,omitempty"`
	KeyIn                    []string                   `json:"key_in,omitempty"`
	KeyNotIn                 []string                   `json:"key_not_in,omitempty"`
	KeyLt                    *string                    `json:"key_lt,omitempty"`
	KeyLte                   *string                    `json:"key_lte,omitempty"`
	KeyGt                    *string                    `json:"key_gt,omitempty"`
	KeyGte                   *string                    `json:"key_gte,omitempty"`
	KeyContains              *string                    `json:"key_contains,omitempty"`
	KeyNotContains           *string                    `json:"key_not_contains,omitempty"`
	KeyStartsWith            *string                    `json:"key_starts_with,omitempty"`
	KeyNotStartsWith         *string                    `json:"key_not_starts_with,omitempty"`
	KeyEndsWith              *string                    `json:"key_ends_with,omitempty"`
	KeyNotEndsWith           *string                    `json:"key_not_ends_with,omitempty"`
	CreatedAt                *string                    `json:"createdAt,omitempty"`
	CreatedAtNot             *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                    `json:"createdAt_gte,omitempty"`
	Recipients               *int32                     `json:"recipients,omitempty"`
	RecipientsNot            *int32                     `json:"recipients_not,omitempty"`
	RecipientsIn             []int32                    `json:"recipients_in,omitempty"`
	RecipientsNotIn          []int32                    `json:"recipients_not_in,omitempty"`
	RecipientsLt             *int32                     `json:"recipients_lt,omitempty"`
	RecipientsLte            *int32                     `json:"recipients_lte,omitempty"`
	RecipientsGt             *int32                     `json:"recipients_gt,omitempty"`
	RecipientsGte            *int32                     `json:"recipients_gte,omitempty"`
	Description              *string                    `json:"description,omitempty"`
	DescriptionNot           *string                    `json:"description_not,omitempty"`
	DescriptionIn            []string                   `json:"description_in,omitempty"`
	DescriptionNotIn         []string                   `json:"description_not_in,omitempty"`
	DescriptionLt            *string                    `json:"description_lt,omitempty"`
	DescriptionLte           *string                    `json:"description_lte,omitempty"`
	DescriptionGt            *string                    `json:"description_gt,omitempty"`
	DescriptionGte           *string                    `json:"description_gte,omitempty"`
	DescriptionContains      *string                    `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                    `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                    `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                    `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                    `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                    `json:"description_not_ends_with,omitempty"`
	And                      []NewsletterSendWhereInput `json:"AND,omitempty"`
	Or                       []NewsletterSendWhereInput `json:"OR,omitempty"`
	Not                      []NewsletterSendWhereInput `json:"NOT,omitempty"`
}

type FavoriteThingCreateInput struct {
	ID          *string `json:"id,omitempty"`
	Priority    int32   `json:"priority"`
	Name        string  `json:"name"`
	Link        string  `json:"link"`
	Description string  `json:"description"`
}

type SessionUpdateInput struct {
	User *UserUpdateOneRequiredInput `json:"user,omitempty"`
}

type BookUpdateManyMutationInput struct {
	Title  *string `json:"title,omitempty"`
	Author *string `json:"author,omitempty"`
	Rank   *int32  `json:"rank,omitempty"`
	Link   *string `json:"link,omitempty"`
}

type ProjectUpdateManyMutationInput struct {
	Priority    *int32  `json:"priority,omitempty"`
	Name        *string `json:"name,omitempty"`
	Link        *string `json:"link,omitempty"`
	Icon        *string `json:"icon,omitempty"`
	Description *string `json:"description,omitempty"`
	Retired     *bool   `json:"retired,omitempty"`
	Revenue     *string `json:"revenue,omitempty"`
	Reason      *string `json:"reason,omitempty"`
}

type BookUpdateInput struct {
	Title  *string `json:"title,omitempty"`
	Author *string `json:"author,omitempty"`
	Rank   *int32  `json:"rank,omitempty"`
	Link   *string `json:"link,omitempty"`
}

type SessionSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *SessionWhereInput              `json:"node,omitempty"`
	And                        []SessionSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []SessionSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []SessionSubscriptionWhereInput `json:"NOT,omitempty"`
}

type SubscriberWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

type UserWhereInput struct {
	ID                        *string          `json:"id,omitempty"`
	IDNot                     *string          `json:"id_not,omitempty"`
	IDIn                      []string         `json:"id_in,omitempty"`
	IDNotIn                   []string         `json:"id_not_in,omitempty"`
	IDLt                      *string          `json:"id_lt,omitempty"`
	IDLte                     *string          `json:"id_lte,omitempty"`
	IDGt                      *string          `json:"id_gt,omitempty"`
	IDGte                     *string          `json:"id_gte,omitempty"`
	IDContains                *string          `json:"id_contains,omitempty"`
	IDNotContains             *string          `json:"id_not_contains,omitempty"`
	IDStartsWith              *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string          `json:"id_not_ends_with,omitempty"`
	Type                      *UserType        `json:"type,omitempty"`
	TypeNot                   *UserType        `json:"type_not,omitempty"`
	TypeIn                    []UserType       `json:"type_in,omitempty"`
	TypeNotIn                 []UserType       `json:"type_not_in,omitempty"`
	CreatedAt                 *string          `json:"createdAt,omitempty"`
	CreatedAtNot              *string          `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string          `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string          `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string          `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string          `json:"createdAt_gte,omitempty"`
	UpdatedAt                 *string          `json:"updatedAt,omitempty"`
	UpdatedAtNot              *string          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn               []string         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn            []string         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt               *string          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte              *string          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt               *string          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte              *string          `json:"updatedAt_gte,omitempty"`
	Email                     *string          `json:"email,omitempty"`
	EmailNot                  *string          `json:"email_not,omitempty"`
	EmailIn                   []string         `json:"email_in,omitempty"`
	EmailNotIn                []string         `json:"email_not_in,omitempty"`
	EmailLt                   *string          `json:"email_lt,omitempty"`
	EmailLte                  *string          `json:"email_lte,omitempty"`
	EmailGt                   *string          `json:"email_gt,omitempty"`
	EmailGte                  *string          `json:"email_gte,omitempty"`
	EmailContains             *string          `json:"email_contains,omitempty"`
	EmailNotContains          *string          `json:"email_not_contains,omitempty"`
	EmailStartsWith           *string          `json:"email_starts_with,omitempty"`
	EmailNotStartsWith        *string          `json:"email_not_starts_with,omitempty"`
	EmailEndsWith             *string          `json:"email_ends_with,omitempty"`
	EmailNotEndsWith          *string          `json:"email_not_ends_with,omitempty"`
	Name                      *string          `json:"name,omitempty"`
	NameNot                   *string          `json:"name_not,omitempty"`
	NameIn                    []string         `json:"name_in,omitempty"`
	NameNotIn                 []string         `json:"name_not_in,omitempty"`
	NameLt                    *string          `json:"name_lt,omitempty"`
	NameLte                   *string          `json:"name_lte,omitempty"`
	NameGt                    *string          `json:"name_gt,omitempty"`
	NameGte                   *string          `json:"name_gte,omitempty"`
	NameContains              *string          `json:"name_contains,omitempty"`
	NameNotContains           *string          `json:"name_not_contains,omitempty"`
	NameStartsWith            *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith         *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith              *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith           *string          `json:"name_not_ends_with,omitempty"`
	PasswordHash              *string          `json:"passwordHash,omitempty"`
	PasswordHashNot           *string          `json:"passwordHash_not,omitempty"`
	PasswordHashIn            []string         `json:"passwordHash_in,omitempty"`
	PasswordHashNotIn         []string         `json:"passwordHash_not_in,omitempty"`
	PasswordHashLt            *string          `json:"passwordHash_lt,omitempty"`
	PasswordHashLte           *string          `json:"passwordHash_lte,omitempty"`
	PasswordHashGt            *string          `json:"passwordHash_gt,omitempty"`
	PasswordHashGte           *string          `json:"passwordHash_gte,omitempty"`
	PasswordHashContains      *string          `json:"passwordHash_contains,omitempty"`
	PasswordHashNotContains   *string          `json:"passwordHash_not_contains,omitempty"`
	PasswordHashStartsWith    *string          `json:"passwordHash_starts_with,omitempty"`
	PasswordHashNotStartsWith *string          `json:"passwordHash_not_starts_with,omitempty"`
	PasswordHashEndsWith      *string          `json:"passwordHash_ends_with,omitempty"`
	PasswordHashNotEndsWith   *string          `json:"passwordHash_not_ends_with,omitempty"`
	And                       []UserWhereInput `json:"AND,omitempty"`
	Or                        []UserWhereInput `json:"OR,omitempty"`
	Not                       []UserWhereInput `json:"NOT,omitempty"`
}

type BookCreateInput struct {
	ID     *string `json:"id,omitempty"`
	Title  string  `json:"title"`
	Author string  `json:"author"`
	Rank   *int32  `json:"rank,omitempty"`
	Link   *string `json:"link,omitempty"`
}

type FavoriteThingWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type SubscriberWhereInput struct {
	ID                 *string                `json:"id,omitempty"`
	IDNot              *string                `json:"id_not,omitempty"`
	IDIn               []string               `json:"id_in,omitempty"`
	IDNotIn            []string               `json:"id_not_in,omitempty"`
	IDLt               *string                `json:"id_lt,omitempty"`
	IDLte              *string                `json:"id_lte,omitempty"`
	IDGt               *string                `json:"id_gt,omitempty"`
	IDGte              *string                `json:"id_gte,omitempty"`
	IDContains         *string                `json:"id_contains,omitempty"`
	IDNotContains      *string                `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                `json:"id_not_ends_with,omitempty"`
	Email              *string                `json:"email,omitempty"`
	EmailNot           *string                `json:"email_not,omitempty"`
	EmailIn            []string               `json:"email_in,omitempty"`
	EmailNotIn         []string               `json:"email_not_in,omitempty"`
	EmailLt            *string                `json:"email_lt,omitempty"`
	EmailLte           *string                `json:"email_lte,omitempty"`
	EmailGt            *string                `json:"email_gt,omitempty"`
	EmailGte           *string                `json:"email_gte,omitempty"`
	EmailContains      *string                `json:"email_contains,omitempty"`
	EmailNotContains   *string                `json:"email_not_contains,omitempty"`
	EmailStartsWith    *string                `json:"email_starts_with,omitempty"`
	EmailNotStartsWith *string                `json:"email_not_starts_with,omitempty"`
	EmailEndsWith      *string                `json:"email_ends_with,omitempty"`
	EmailNotEndsWith   *string                `json:"email_not_ends_with,omitempty"`
	Name               *string                `json:"name,omitempty"`
	NameNot            *string                `json:"name_not,omitempty"`
	NameIn             []string               `json:"name_in,omitempty"`
	NameNotIn          []string               `json:"name_not_in,omitempty"`
	NameLt             *string                `json:"name_lt,omitempty"`
	NameLte            *string                `json:"name_lte,omitempty"`
	NameGt             *string                `json:"name_gt,omitempty"`
	NameGte            *string                `json:"name_gte,omitempty"`
	NameContains       *string                `json:"name_contains,omitempty"`
	NameNotContains    *string                `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                `json:"name_not_ends_with,omitempty"`
	Confirmed          *bool                  `json:"confirmed,omitempty"`
	ConfirmedNot       *bool                  `json:"confirmed_not,omitempty"`
	Unsubscribed       *bool                  `json:"unsubscribed,omitempty"`
	UnsubscribedNot    *bool                  `json:"unsubscribed_not,omitempty"`
	And                []SubscriberWhereInput `json:"AND,omitempty"`
	Or                 []SubscriberWhereInput `json:"OR,omitempty"`
	Not                []SubscriberWhereInput `json:"NOT,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Type         *UserType `json:"type,omitempty"`
	Email        *string   `json:"email,omitempty"`
	Name         *string   `json:"name,omitempty"`
	PasswordHash *string   `json:"passwordHash,omitempty"`
}

type BlogPostUpdateManyMutationInput struct {
	Slug      *string `json:"slug,omitempty"`
	Published *bool   `json:"published,omitempty"`
	Image     *string `json:"image,omitempty"`
	Title     *string `json:"title,omitempty"`
	Date      *string `json:"date,omitempty"`
	Content   *string `json:"content,omitempty"`
	Tags      *string `json:"tags,omitempty"`
}

type SubscriberUpdateInput struct {
	Email        *string `json:"email,omitempty"`
	Name         *string `json:"name,omitempty"`
	Confirmed    *bool   `json:"confirmed,omitempty"`
	Unsubscribed *bool   `json:"unsubscribed,omitempty"`
}

type UserUpsertNestedInput struct {
	Update UserUpdateDataInput `json:"update"`
	Create UserCreateInput     `json:"create"`
}

type SessionCreateInput struct {
	ID   *string            `json:"id,omitempty"`
	User UserCreateOneInput `json:"user"`
}

type UserUpdateDataInput struct {
	Type         *UserType `json:"type,omitempty"`
	Email        *string   `json:"email,omitempty"`
	Name         *string   `json:"name,omitempty"`
	PasswordHash *string   `json:"passwordHash,omitempty"`
}

type ProjectSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *ProjectWhereInput              `json:"node,omitempty"`
	And                        []ProjectSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ProjectSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ProjectSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserUpdateOneRequiredInput struct {
	Create  *UserCreateInput       `json:"create,omitempty"`
	Update  *UserUpdateDataInput   `json:"update,omitempty"`
	Upsert  *UserUpsertNestedInput `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput  `json:"connect,omitempty"`
}

type FavoriteThingWhereInput struct {
	ID                       *string                   `json:"id,omitempty"`
	IDNot                    *string                   `json:"id_not,omitempty"`
	IDIn                     []string                  `json:"id_in,omitempty"`
	IDNotIn                  []string                  `json:"id_not_in,omitempty"`
	IDLt                     *string                   `json:"id_lt,omitempty"`
	IDLte                    *string                   `json:"id_lte,omitempty"`
	IDGt                     *string                   `json:"id_gt,omitempty"`
	IDGte                    *string                   `json:"id_gte,omitempty"`
	IDContains               *string                   `json:"id_contains,omitempty"`
	IDNotContains            *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                   `json:"id_not_ends_with,omitempty"`
	Priority                 *int32                    `json:"priority,omitempty"`
	PriorityNot              *int32                    `json:"priority_not,omitempty"`
	PriorityIn               []int32                   `json:"priority_in,omitempty"`
	PriorityNotIn            []int32                   `json:"priority_not_in,omitempty"`
	PriorityLt               *int32                    `json:"priority_lt,omitempty"`
	PriorityLte              *int32                    `json:"priority_lte,omitempty"`
	PriorityGt               *int32                    `json:"priority_gt,omitempty"`
	PriorityGte              *int32                    `json:"priority_gte,omitempty"`
	Name                     *string                   `json:"name,omitempty"`
	NameNot                  *string                   `json:"name_not,omitempty"`
	NameIn                   []string                  `json:"name_in,omitempty"`
	NameNotIn                []string                  `json:"name_not_in,omitempty"`
	NameLt                   *string                   `json:"name_lt,omitempty"`
	NameLte                  *string                   `json:"name_lte,omitempty"`
	NameGt                   *string                   `json:"name_gt,omitempty"`
	NameGte                  *string                   `json:"name_gte,omitempty"`
	NameContains             *string                   `json:"name_contains,omitempty"`
	NameNotContains          *string                   `json:"name_not_contains,omitempty"`
	NameStartsWith           *string                   `json:"name_starts_with,omitempty"`
	NameNotStartsWith        *string                   `json:"name_not_starts_with,omitempty"`
	NameEndsWith             *string                   `json:"name_ends_with,omitempty"`
	NameNotEndsWith          *string                   `json:"name_not_ends_with,omitempty"`
	Link                     *string                   `json:"link,omitempty"`
	LinkNot                  *string                   `json:"link_not,omitempty"`
	LinkIn                   []string                  `json:"link_in,omitempty"`
	LinkNotIn                []string                  `json:"link_not_in,omitempty"`
	LinkLt                   *string                   `json:"link_lt,omitempty"`
	LinkLte                  *string                   `json:"link_lte,omitempty"`
	LinkGt                   *string                   `json:"link_gt,omitempty"`
	LinkGte                  *string                   `json:"link_gte,omitempty"`
	LinkContains             *string                   `json:"link_contains,omitempty"`
	LinkNotContains          *string                   `json:"link_not_contains,omitempty"`
	LinkStartsWith           *string                   `json:"link_starts_with,omitempty"`
	LinkNotStartsWith        *string                   `json:"link_not_starts_with,omitempty"`
	LinkEndsWith             *string                   `json:"link_ends_with,omitempty"`
	LinkNotEndsWith          *string                   `json:"link_not_ends_with,omitempty"`
	Description              *string                   `json:"description,omitempty"`
	DescriptionNot           *string                   `json:"description_not,omitempty"`
	DescriptionIn            []string                  `json:"description_in,omitempty"`
	DescriptionNotIn         []string                  `json:"description_not_in,omitempty"`
	DescriptionLt            *string                   `json:"description_lt,omitempty"`
	DescriptionLte           *string                   `json:"description_lte,omitempty"`
	DescriptionGt            *string                   `json:"description_gt,omitempty"`
	DescriptionGte           *string                   `json:"description_gte,omitempty"`
	DescriptionContains      *string                   `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                   `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                   `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                   `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                   `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                   `json:"description_not_ends_with,omitempty"`
	And                      []FavoriteThingWhereInput `json:"AND,omitempty"`
	Or                       []FavoriteThingWhereInput `json:"OR,omitempty"`
	Not                      []FavoriteThingWhereInput `json:"NOT,omitempty"`
}

type UserCreateOneInput struct {
	Create  *UserCreateInput      `json:"create,omitempty"`
	Connect *UserWhereUniqueInput `json:"connect,omitempty"`
}

type UserCreateInput struct {
	ID           *string   `json:"id,omitempty"`
	Type         *UserType `json:"type,omitempty"`
	Email        string    `json:"email"`
	Name         string    `json:"name"`
	PasswordHash string    `json:"passwordHash"`
}

type BlogPostUpdateInput struct {
	Slug      *string                     `json:"slug,omitempty"`
	Published *bool                       `json:"published,omitempty"`
	Image     *string                     `json:"image,omitempty"`
	Title     *string                     `json:"title,omitempty"`
	Date      *string                     `json:"date,omitempty"`
	Author    *UserUpdateOneRequiredInput `json:"author,omitempty"`
	Content   *string                     `json:"content,omitempty"`
	Tags      *string                     `json:"tags,omitempty"`
}

type UserWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

type SubscriberUpdateManyMutationInput struct {
	Email        *string `json:"email,omitempty"`
	Name         *string `json:"name,omitempty"`
	Confirmed    *bool   `json:"confirmed,omitempty"`
	Unsubscribed *bool   `json:"unsubscribed,omitempty"`
}

type FavoriteThingSubscriptionWhereInput struct {
	MutationIn                 []MutationType                        `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                               `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                              `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                              `json:"updatedFields_contains_some,omitempty"`
	Node                       *FavoriteThingWhereInput              `json:"node,omitempty"`
	And                        []FavoriteThingSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FavoriteThingSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FavoriteThingSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type SubscriberCreateInput struct {
	ID           *string `json:"id,omitempty"`
	Email        string  `json:"email"`
	Name         string  `json:"name"`
	Confirmed    bool    `json:"confirmed"`
	Unsubscribed bool    `json:"unsubscribed"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserPreviousValuesFields = []string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"}

type UserPreviousValues struct {
	ID           string   `json:"id"`
	Type         UserType `json:"type"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
	Email        string   `json:"email"`
	Name         string   `json:"name"`
	PasswordHash string   `json:"passwordHash"`
}

type FavoriteThingEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FavoriteThingEdgeExec) Node() *FavoriteThingExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FavoriteThing"},
		"node",
		[]string{"id", "priority", "name", "link", "description"})

	return &FavoriteThingExec{ret}
}

func (instance FavoriteThingEdgeExec) Exec(ctx context.Context) (*FavoriteThingEdge, error) {
	var v FavoriteThingEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FavoriteThingEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FavoriteThingEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FavoriteThingEdgeExecArray) Exec(ctx context.Context) ([]FavoriteThingEdge, error) {
	var v []FavoriteThingEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FavoriteThingEdgeFields = []string{"cursor"}

type FavoriteThingEdge struct {
	Node   FavoriteThing `json:"node"`
	Cursor string        `json:"cursor"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserEdgeFields = []string{"cursor"}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}

type BlogPostConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BlogPostConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BlogPostConnectionExec) Edges() *BlogPostEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BlogPostWhereInput", "BlogPostOrderByInput", "BlogPostEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "BlogPost"},
		"node",
		BlogPostFields)

	return &BlogPostEdgeExecArray{nodes}
}

func (instance *BlogPostConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBlogPost"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BlogPostConnectionExec) Exec(ctx context.Context) (*BlogPostConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &BlogPostConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance BlogPostConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlogPostConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BlogPostConnectionExecArray) Exec(ctx context.Context) ([]BlogPostConnection, error) {
	var v []BlogPostConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BlogPostConnectionFields = []string{}

type BlogPostConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []BlogPostEdge `json:"edges"`
}

type BlogPostEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BlogPostEdgeExec) Node() *BlogPostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BlogPost"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "slug", "published", "image", "title", "date", "content", "tags"})

	return &BlogPostExec{ret}
}

func (instance BlogPostEdgeExec) Exec(ctx context.Context) (*BlogPostEdge, error) {
	var v BlogPostEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlogPostEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlogPostEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BlogPostEdgeExecArray) Exec(ctx context.Context) ([]BlogPostEdge, error) {
	var v []BlogPostEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BlogPostEdgeFields = []string{"cursor"}

type BlogPostEdge struct {
	Node   BlogPost `json:"node"`
	Cursor string   `json:"cursor"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "User"},
		"node",
		UserFields)

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &UserConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserConnectionFields = []string{}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}

type FavoriteThingConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FavoriteThingConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FavoriteThingConnectionExec) Edges() *FavoriteThingEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"FavoriteThingWhereInput", "FavoriteThingOrderByInput", "FavoriteThingEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "FavoriteThing"},
		"node",
		FavoriteThingFields)

	return &FavoriteThingEdgeExecArray{nodes}
}

func (instance *FavoriteThingConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFavoriteThing"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance FavoriteThingConnectionExec) Exec(ctx context.Context) (*FavoriteThingConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &FavoriteThingConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance FavoriteThingConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FavoriteThingConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FavoriteThingConnectionExecArray) Exec(ctx context.Context) ([]FavoriteThingConnection, error) {
	var v []FavoriteThingConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FavoriteThingConnectionFields = []string{}

type FavoriteThingConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []FavoriteThingEdge `json:"edges"`
}

type SubscriberConnectionExec struct {
	exec *prisma.Exec
}

func (instance *SubscriberConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *SubscriberConnectionExec) Edges() *SubscriberEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"SubscriberWhereInput", "SubscriberOrderByInput", "SubscriberEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Subscriber"},
		"node",
		SubscriberFields)

	return &SubscriberEdgeExecArray{nodes}
}

func (instance *SubscriberConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateSubscriber"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance SubscriberConnectionExec) Exec(ctx context.Context) (*SubscriberConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &SubscriberConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance SubscriberConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SubscriberConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance SubscriberConnectionExecArray) Exec(ctx context.Context) ([]SubscriberConnection, error) {
	var v []SubscriberConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SubscriberConnectionFields = []string{}

type SubscriberConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []SubscriberEdge `json:"edges"`
}

type FavoriteThingExec struct {
	exec *prisma.Exec
}

func (instance FavoriteThingExec) Exec(ctx context.Context) (*FavoriteThing, error) {
	var v FavoriteThing
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FavoriteThingExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FavoriteThingExecArray struct {
	exec *prisma.Exec
}

func (instance FavoriteThingExecArray) Exec(ctx context.Context) ([]FavoriteThing, error) {
	var v []FavoriteThing
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FavoriteThingFields = []string{"id", "priority", "name", "link", "description"}

type FavoriteThing struct {
	ID          string `json:"id"`
	Priority    int32  `json:"priority"`
	Name        string `json:"name"`
	Link        string `json:"link"`
	Description string `json:"description"`
}

type SubscriberSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *SubscriberSubscriptionPayloadExec) Node() *SubscriberExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Subscriber"},
		"node",
		[]string{"id", "email", "name", "confirmed", "unsubscribed"})

	return &SubscriberExec{ret}
}

func (instance *SubscriberSubscriptionPayloadExec) PreviousValues() *SubscriberPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SubscriberPreviousValues"},
		"previousValues",
		[]string{"id", "email", "name", "confirmed", "unsubscribed"})

	return &SubscriberPreviousValuesExec{ret}
}

func (instance SubscriberSubscriptionPayloadExec) Exec(ctx context.Context) (*SubscriberSubscriptionPayload, error) {
	var v SubscriberSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SubscriberSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SubscriberSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance SubscriberSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]SubscriberSubscriptionPayload, error) {
	var v []SubscriberSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SubscriberSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type SubscriberSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Subscriber  `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type SubscriberExec struct {
	exec *prisma.Exec
}

func (instance SubscriberExec) Exec(ctx context.Context) (*Subscriber, error) {
	var v Subscriber
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SubscriberExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SubscriberExecArray struct {
	exec *prisma.Exec
}

func (instance SubscriberExecArray) Exec(ctx context.Context) ([]Subscriber, error) {
	var v []Subscriber
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SubscriberFields = []string{"id", "email", "name", "confirmed", "unsubscribed"}

type Subscriber struct {
	ID           string `json:"id"`
	Email        string `json:"email"`
	Name         string `json:"name"`
	Confirmed    bool   `json:"confirmed"`
	Unsubscribed bool   `json:"unsubscribed"`
}

type BlogPostSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BlogPostSubscriptionPayloadExec) Node() *BlogPostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BlogPost"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "slug", "published", "image", "title", "date", "content", "tags"})

	return &BlogPostExec{ret}
}

func (instance *BlogPostSubscriptionPayloadExec) PreviousValues() *BlogPostPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BlogPostPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "slug", "published", "image", "title", "date", "content", "tags"})

	return &BlogPostPreviousValuesExec{ret}
}

func (instance BlogPostSubscriptionPayloadExec) Exec(ctx context.Context) (*BlogPostSubscriptionPayload, error) {
	var v BlogPostSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlogPostSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlogPostSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BlogPostSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BlogPostSubscriptionPayload, error) {
	var v []BlogPostSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BlogPostSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type BlogPostSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *BlogPost    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type SessionEdgeExec struct {
	exec *prisma.Exec
}

func (instance *SessionEdgeExec) Node() *SessionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Session"},
		"node",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

func (instance SessionEdgeExec) Exec(ctx context.Context) (*SessionEdge, error) {
	var v SessionEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance SessionEdgeExecArray) Exec(ctx context.Context) ([]SessionEdge, error) {
	var v []SessionEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionEdgeFields = []string{"cursor"}

type SessionEdge struct {
	Node   Session `json:"node"`
	Cursor string  `json:"cursor"`
}

type BlogPostPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BlogPostPreviousValuesExec) Exec(ctx context.Context) (*BlogPostPreviousValues, error) {
	var v BlogPostPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlogPostPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlogPostPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BlogPostPreviousValuesExecArray) Exec(ctx context.Context) ([]BlogPostPreviousValues, error) {
	var v []BlogPostPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BlogPostPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "slug", "published", "image", "title", "date", "content", "tags"}

type BlogPostPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Slug      string `json:"slug"`
	Published bool   `json:"published"`
	Image     string `json:"image"`
	Title     string `json:"title"`
	Date      string `json:"date"`
	Content   string `json:"content"`
	Tags      string `json:"tags"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type BookSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BookSubscriptionPayloadExec) Node() *BookExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Book"},
		"node",
		[]string{"id", "title", "author", "rank", "link"})

	return &BookExec{ret}
}

func (instance *BookSubscriptionPayloadExec) PreviousValues() *BookPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BookPreviousValues"},
		"previousValues",
		[]string{"id", "title", "author", "rank", "link"})

	return &BookPreviousValuesExec{ret}
}

func (instance BookSubscriptionPayloadExec) Exec(ctx context.Context) (*BookSubscriptionPayload, error) {
	var v BookSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BookSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BookSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BookSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BookSubscriptionPayload, error) {
	var v []BookSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BookSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type BookSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Book        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ProjectConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ProjectConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ProjectConnectionExec) Edges() *ProjectEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ProjectWhereInput", "ProjectOrderByInput", "ProjectEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Project"},
		"node",
		ProjectFields)

	return &ProjectEdgeExecArray{nodes}
}

func (instance *ProjectConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateProject"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ProjectConnectionExec) Exec(ctx context.Context) (*ProjectConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ProjectConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ProjectConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProjectConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ProjectConnectionExecArray) Exec(ctx context.Context) ([]ProjectConnection, error) {
	var v []ProjectConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProjectConnectionFields = []string{}

type ProjectConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []ProjectEdge `json:"edges"`
}

type BookPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BookPreviousValuesExec) Exec(ctx context.Context) (*BookPreviousValues, error) {
	var v BookPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BookPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BookPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BookPreviousValuesExecArray) Exec(ctx context.Context) ([]BookPreviousValues, error) {
	var v []BookPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BookPreviousValuesFields = []string{"id", "title", "author", "rank", "link"}

type BookPreviousValues struct {
	ID     string  `json:"id"`
	Title  string  `json:"title"`
	Author string  `json:"author"`
	Rank   *int32  `json:"rank,omitempty"`
	Link   *string `json:"link,omitempty"`
}

type ProjectExec struct {
	exec *prisma.Exec
}

func (instance ProjectExec) Exec(ctx context.Context) (*Project, error) {
	var v Project
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProjectExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProjectExecArray struct {
	exec *prisma.Exec
}

func (instance ProjectExecArray) Exec(ctx context.Context) ([]Project, error) {
	var v []Project
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProjectFields = []string{"id", "priority", "name", "link", "icon", "description", "retired", "revenue", "reason"}

type Project struct {
	ID          string  `json:"id"`
	Priority    int32   `json:"priority"`
	Name        string  `json:"name"`
	Link        string  `json:"link"`
	Icon        string  `json:"icon"`
	Description string  `json:"description"`
	Retired     bool    `json:"retired"`
	Revenue     string  `json:"revenue"`
	Reason      *string `json:"reason,omitempty"`
}

type BookEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BookEdgeExec) Node() *BookExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Book"},
		"node",
		[]string{"id", "title", "author", "rank", "link"})

	return &BookExec{ret}
}

func (instance BookEdgeExec) Exec(ctx context.Context) (*BookEdge, error) {
	var v BookEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BookEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BookEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BookEdgeExecArray) Exec(ctx context.Context) ([]BookEdge, error) {
	var v []BookEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BookEdgeFields = []string{"cursor"}

type BookEdge struct {
	Node   Book   `json:"node"`
	Cursor string `json:"cursor"`
}

type NewsletterSendEdgeExec struct {
	exec *prisma.Exec
}

func (instance *NewsletterSendEdgeExec) Node() *NewsletterSendExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "NewsletterSend"},
		"node",
		[]string{"id", "key", "createdAt", "recipients", "description"})

	return &NewsletterSendExec{ret}
}

func (instance NewsletterSendEdgeExec) Exec(ctx context.Context) (*NewsletterSendEdge, error) {
	var v NewsletterSendEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NewsletterSendEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NewsletterSendEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance NewsletterSendEdgeExecArray) Exec(ctx context.Context) ([]NewsletterSendEdge, error) {
	var v []NewsletterSendEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NewsletterSendEdgeFields = []string{"cursor"}

type NewsletterSendEdge struct {
	Node   NewsletterSend `json:"node"`
	Cursor string         `json:"cursor"`
}

type FavoriteThingSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FavoriteThingSubscriptionPayloadExec) Node() *FavoriteThingExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FavoriteThing"},
		"node",
		[]string{"id", "priority", "name", "link", "description"})

	return &FavoriteThingExec{ret}
}

func (instance *FavoriteThingSubscriptionPayloadExec) PreviousValues() *FavoriteThingPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FavoriteThingPreviousValues"},
		"previousValues",
		[]string{"id", "priority", "name", "link", "description"})

	return &FavoriteThingPreviousValuesExec{ret}
}

func (instance FavoriteThingSubscriptionPayloadExec) Exec(ctx context.Context) (*FavoriteThingSubscriptionPayload, error) {
	var v FavoriteThingSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FavoriteThingSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FavoriteThingSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FavoriteThingSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FavoriteThingSubscriptionPayload, error) {
	var v []FavoriteThingSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FavoriteThingSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type FavoriteThingSubscriptionPayload struct {
	Mutation      MutationType   `json:"mutation"`
	Node          *FavoriteThing `json:"node,omitempty"`
	UpdatedFields []string       `json:"updatedFields,omitempty"`
}

type UserExec struct {
	exec *prisma.Exec
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserFields = []string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"}

type User struct {
	ID           string   `json:"id"`
	Type         UserType `json:"type"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
	Email        string   `json:"email"`
	Name         string   `json:"name"`
	PasswordHash string   `json:"passwordHash"`
}

type FavoriteThingPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FavoriteThingPreviousValuesExec) Exec(ctx context.Context) (*FavoriteThingPreviousValues, error) {
	var v FavoriteThingPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FavoriteThingPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FavoriteThingPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FavoriteThingPreviousValuesExecArray) Exec(ctx context.Context) ([]FavoriteThingPreviousValues, error) {
	var v []FavoriteThingPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FavoriteThingPreviousValuesFields = []string{"id", "priority", "name", "link", "description"}

type FavoriteThingPreviousValues struct {
	ID          string `json:"id"`
	Priority    int32  `json:"priority"`
	Name        string `json:"name"`
	Link        string `json:"link"`
	Description string `json:"description"`
}

type SubscriberEdgeExec struct {
	exec *prisma.Exec
}

func (instance *SubscriberEdgeExec) Node() *SubscriberExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Subscriber"},
		"node",
		[]string{"id", "email", "name", "confirmed", "unsubscribed"})

	return &SubscriberExec{ret}
}

func (instance SubscriberEdgeExec) Exec(ctx context.Context) (*SubscriberEdge, error) {
	var v SubscriberEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SubscriberEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SubscriberEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance SubscriberEdgeExecArray) Exec(ctx context.Context) ([]SubscriberEdge, error) {
	var v []SubscriberEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SubscriberEdgeFields = []string{"cursor"}

type SubscriberEdge struct {
	Node   Subscriber `json:"node"`
	Cursor string     `json:"cursor"`
}

type BookConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BookConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BookConnectionExec) Edges() *BookEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BookWhereInput", "BookOrderByInput", "BookEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Book"},
		"node",
		BookFields)

	return &BookEdgeExecArray{nodes}
}

func (instance *BookConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBook"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BookConnectionExec) Exec(ctx context.Context) (*BookConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &BookConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance BookConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BookConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BookConnectionExecArray) Exec(ctx context.Context) ([]BookConnection, error) {
	var v []BookConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BookConnectionFields = []string{}

type BookConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []BookEdge `json:"edges"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type NewsletterSendSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *NewsletterSendSubscriptionPayloadExec) Node() *NewsletterSendExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "NewsletterSend"},
		"node",
		[]string{"id", "key", "createdAt", "recipients", "description"})

	return &NewsletterSendExec{ret}
}

func (instance *NewsletterSendSubscriptionPayloadExec) PreviousValues() *NewsletterSendPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "NewsletterSendPreviousValues"},
		"previousValues",
		[]string{"id", "key", "createdAt", "recipients", "description"})

	return &NewsletterSendPreviousValuesExec{ret}
}

func (instance NewsletterSendSubscriptionPayloadExec) Exec(ctx context.Context) (*NewsletterSendSubscriptionPayload, error) {
	var v NewsletterSendSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NewsletterSendSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NewsletterSendSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance NewsletterSendSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]NewsletterSendSubscriptionPayload, error) {
	var v []NewsletterSendSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NewsletterSendSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type NewsletterSendSubscriptionPayload struct {
	Mutation      MutationType    `json:"mutation"`
	Node          *NewsletterSend `json:"node,omitempty"`
	UpdatedFields []string        `json:"updatedFields,omitempty"`
}

type SessionConnectionExec struct {
	exec *prisma.Exec
}

func (instance *SessionConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *SessionConnectionExec) Edges() *SessionEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"SessionWhereInput", "SessionOrderByInput", "SessionEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Session"},
		"node",
		SessionFields)

	return &SessionEdgeExecArray{nodes}
}

func (instance *SessionConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateSession"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance SessionConnectionExec) Exec(ctx context.Context) (*SessionConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &SessionConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance SessionConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance SessionConnectionExecArray) Exec(ctx context.Context) ([]SessionConnection, error) {
	var v []SessionConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionConnectionFields = []string{}

type SessionConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []SessionEdge `json:"edges"`
}

type NewsletterSendPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance NewsletterSendPreviousValuesExec) Exec(ctx context.Context) (*NewsletterSendPreviousValues, error) {
	var v NewsletterSendPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NewsletterSendPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NewsletterSendPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance NewsletterSendPreviousValuesExecArray) Exec(ctx context.Context) ([]NewsletterSendPreviousValues, error) {
	var v []NewsletterSendPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NewsletterSendPreviousValuesFields = []string{"id", "key", "createdAt", "recipients", "description"}

type NewsletterSendPreviousValues struct {
	ID          string `json:"id"`
	Key         string `json:"key"`
	CreatedAt   string `json:"createdAt"`
	Recipients  int32  `json:"recipients"`
	Description string `json:"description"`
}

type ProjectEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ProjectEdgeExec) Node() *ProjectExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Project"},
		"node",
		[]string{"id", "priority", "name", "link", "icon", "description", "retired", "revenue", "reason"})

	return &ProjectExec{ret}
}

func (instance ProjectEdgeExec) Exec(ctx context.Context) (*ProjectEdge, error) {
	var v ProjectEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProjectEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProjectEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ProjectEdgeExecArray) Exec(ctx context.Context) ([]ProjectEdge, error) {
	var v []ProjectEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProjectEdgeFields = []string{"cursor"}

type ProjectEdge struct {
	Node   Project `json:"node"`
	Cursor string  `json:"cursor"`
}

type BookExec struct {
	exec *prisma.Exec
}

func (instance BookExec) Exec(ctx context.Context) (*Book, error) {
	var v Book
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BookExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BookExecArray struct {
	exec *prisma.Exec
}

func (instance BookExecArray) Exec(ctx context.Context) ([]Book, error) {
	var v []Book
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BookFields = []string{"id", "title", "author", "rank", "link"}

type Book struct {
	ID     string  `json:"id"`
	Title  string  `json:"title"`
	Author string  `json:"author"`
	Rank   *int32  `json:"rank,omitempty"`
	Link   *string `json:"link,omitempty"`
}

type ProjectSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ProjectSubscriptionPayloadExec) Node() *ProjectExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Project"},
		"node",
		[]string{"id", "priority", "name", "link", "icon", "description", "retired", "revenue", "reason"})

	return &ProjectExec{ret}
}

func (instance *ProjectSubscriptionPayloadExec) PreviousValues() *ProjectPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProjectPreviousValues"},
		"previousValues",
		[]string{"id", "priority", "name", "link", "icon", "description", "retired", "revenue", "reason"})

	return &ProjectPreviousValuesExec{ret}
}

func (instance ProjectSubscriptionPayloadExec) Exec(ctx context.Context) (*ProjectSubscriptionPayload, error) {
	var v ProjectSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProjectSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProjectSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ProjectSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ProjectSubscriptionPayload, error) {
	var v []ProjectSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProjectSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ProjectSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Project     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type NewsletterSendExec struct {
	exec *prisma.Exec
}

func (instance NewsletterSendExec) Exec(ctx context.Context) (*NewsletterSend, error) {
	var v NewsletterSend
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NewsletterSendExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NewsletterSendExecArray struct {
	exec *prisma.Exec
}

func (instance NewsletterSendExecArray) Exec(ctx context.Context) ([]NewsletterSend, error) {
	var v []NewsletterSend
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NewsletterSendFields = []string{"id", "key", "createdAt", "recipients", "description"}

type NewsletterSend struct {
	ID          string `json:"id"`
	Key         string `json:"key"`
	CreatedAt   string `json:"createdAt"`
	Recipients  int32  `json:"recipients"`
	Description string `json:"description"`
}

type SessionPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance SessionPreviousValuesExec) Exec(ctx context.Context) (*SessionPreviousValues, error) {
	var v SessionPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance SessionPreviousValuesExecArray) Exec(ctx context.Context) ([]SessionPreviousValues, error) {
	var v []SessionPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionPreviousValuesFields = []string{"id", "createdAt"}

type SessionPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
}

type SessionSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *SessionSubscriptionPayloadExec) Node() *SessionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Session"},
		"node",
		[]string{"id", "createdAt"})

	return &SessionExec{ret}
}

func (instance *SessionSubscriptionPayloadExec) PreviousValues() *SessionPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "SessionPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt"})

	return &SessionPreviousValuesExec{ret}
}

func (instance SessionSubscriptionPayloadExec) Exec(ctx context.Context) (*SessionSubscriptionPayload, error) {
	var v SessionSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance SessionSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]SessionSubscriptionPayload, error) {
	var v []SessionSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type SessionSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Session     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ProjectPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ProjectPreviousValuesExec) Exec(ctx context.Context) (*ProjectPreviousValues, error) {
	var v ProjectPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProjectPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProjectPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ProjectPreviousValuesExecArray) Exec(ctx context.Context) ([]ProjectPreviousValues, error) {
	var v []ProjectPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ProjectPreviousValuesFields = []string{"id", "priority", "name", "link", "icon", "description", "retired", "revenue", "reason"}

type ProjectPreviousValues struct {
	ID          string  `json:"id"`
	Priority    int32   `json:"priority"`
	Name        string  `json:"name"`
	Link        string  `json:"link"`
	Icon        string  `json:"icon"`
	Description string  `json:"description"`
	Retired     bool    `json:"retired"`
	Revenue     string  `json:"revenue"`
	Reason      *string `json:"reason,omitempty"`
}

type SessionExec struct {
	exec *prisma.Exec
}

func (instance *SessionExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (instance SessionExec) Exec(ctx context.Context) (*Session, error) {
	var v Session
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SessionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SessionExecArray struct {
	exec *prisma.Exec
}

func (instance SessionExecArray) Exec(ctx context.Context) ([]Session, error) {
	var v []Session
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SessionFields = []string{"id", "createdAt"}

type Session struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
}

type BlogPostExec struct {
	exec *prisma.Exec
}

func (instance *BlogPostExec) Author() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"author",
		[]string{"id", "type", "createdAt", "updatedAt", "email", "name", "passwordHash"})

	return &UserExec{ret}
}

func (instance BlogPostExec) Exec(ctx context.Context) (*BlogPost, error) {
	var v BlogPost
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BlogPostExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BlogPostExecArray struct {
	exec *prisma.Exec
}

func (instance BlogPostExecArray) Exec(ctx context.Context) ([]BlogPost, error) {
	var v []BlogPost
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BlogPostFields = []string{"id", "createdAt", "updatedAt", "slug", "published", "image", "title", "date", "content", "tags"}

type BlogPost struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Slug      string `json:"slug"`
	Published bool   `json:"published"`
	Image     string `json:"image"`
	Title     string `json:"title"`
	Date      string `json:"date"`
	Content   string `json:"content"`
	Tags      string `json:"tags"`
}

type NewsletterSendConnectionExec struct {
	exec *prisma.Exec
}

func (instance *NewsletterSendConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *NewsletterSendConnectionExec) Edges() *NewsletterSendEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"NewsletterSendWhereInput", "NewsletterSendOrderByInput", "NewsletterSendEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "NewsletterSend"},
		"node",
		NewsletterSendFields)

	return &NewsletterSendEdgeExecArray{nodes}
}

func (instance *NewsletterSendConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateNewsletterSend"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance NewsletterSendConnectionExec) Exec(ctx context.Context) (*NewsletterSendConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &NewsletterSendConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance NewsletterSendConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NewsletterSendConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance NewsletterSendConnectionExecArray) Exec(ctx context.Context) ([]NewsletterSendConnection, error) {
	var v []NewsletterSendConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NewsletterSendConnectionFields = []string{}

type NewsletterSendConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []NewsletterSendEdge `json:"edges"`
}

type SubscriberPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance SubscriberPreviousValuesExec) Exec(ctx context.Context) (*SubscriberPreviousValues, error) {
	var v SubscriberPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance SubscriberPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type SubscriberPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance SubscriberPreviousValuesExecArray) Exec(ctx context.Context) ([]SubscriberPreviousValues, error) {
	var v []SubscriberPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var SubscriberPreviousValuesFields = []string{"id", "email", "name", "confirmed", "unsubscribed"}

type SubscriberPreviousValues struct {
	ID           string `json:"id"`
	Email        string `json:"email"`
	Name         string `json:"name"`
	Confirmed    bool   `json:"confirmed"`
	Unsubscribed bool   `json:"unsubscribed"`
}
